<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 4 PLS - Discriminant Analysis (PLS-DA) | mixOmics vignette</title>
  <meta name="description" content="Vignette for the R package mixOmics" />
  <meta name="generator" content="bookdown 0.12 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 4 PLS - Discriminant Analysis (PLS-DA) | mixOmics vignette" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="Vignette for the R package mixOmics" />
  <meta name="github-repo" content="mixOmicsTeam/mixOmics" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 4 PLS - Discriminant Analysis (PLS-DA) | mixOmics vignette" />
  
  <meta name="twitter:description" content="Vignette for the R package mixOmics" />
  

<meta name="author" content="Kim-Anh Le Cao, Sebastien Dejean, Al J Abadi" />



  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="pca.html">
<link rel="next" href="pls.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Preface</a></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#intro:datatypes"><i class="fa fa-check"></i><b>1.1</b> Input data</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#methods"><i class="fa fa-check"></i><b>1.2</b> Methods</a><ul>
<li class="chapter" data-level="1.2.1" data-path="intro.html"><a href="intro.html#intro:background"><i class="fa fa-check"></i><b>1.2.1</b> Some background knowledge</a></li>
<li class="chapter" data-level="1.2.2" data-path="intro.html"><a href="intro.html#intro:overview"><i class="fa fa-check"></i><b>1.2.2</b> Overview</a></li>
<li class="chapter" data-level="1.2.3" data-path="intro.html"><a href="intro.html#intro:pubs"><i class="fa fa-check"></i><b>1.2.3</b> Key publications</a></li>
</ul></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#outline-of-this-vignette"><i class="fa fa-check"></i><b>1.3</b> Outline of this Vignette</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#other-methods-not-covered-in-this-vignette"><i class="fa fa-check"></i><b>1.4</b> Other methods not covered in this vignette</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="start.html"><a href="start.html"><i class="fa fa-check"></i><b>2</b> Let’s get started</a><ul>
<li class="chapter" data-level="2.1" data-path="start.html"><a href="start.html#installation"><i class="fa fa-check"></i><b>2.1</b> Installation</a></li>
<li class="chapter" data-level="2.2" data-path="start.html"><a href="start.html#start:upload"><i class="fa fa-check"></i><b>2.2</b> Load the package</a></li>
<li class="chapter" data-level="2.3" data-path="start.html"><a href="start.html#upload-data"><i class="fa fa-check"></i><b>2.3</b> Upload data</a></li>
<li class="chapter" data-level="2.4" data-path="start.html"><a href="start.html#start:PCA"><i class="fa fa-check"></i><b>2.4</b> Quick start in <code>mixOmics</code></a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="pca.html"><a href="pca.html"><i class="fa fa-check"></i><b>3</b> Principal Component Analysis (PCA)</a><ul>
<li class="chapter" data-level="3.1" data-path="pca.html"><a href="pca.html#biological-question"><i class="fa fa-check"></i><b>3.1</b> Biological question</a></li>
<li class="chapter" data-level="3.2" data-path="pca.html"><a href="pca.html#the-liver.toxicity-study"><i class="fa fa-check"></i><b>3.2</b> The <code>liver.toxicity</code> study</a></li>
<li class="chapter" data-level="3.3" data-path="pca.html"><a href="pca.html#principle-of-pca"><i class="fa fa-check"></i><b>3.3</b> Principle of PCA</a></li>
<li class="chapter" data-level="3.4" data-path="pca.html"><a href="pca.html#load-the-data"><i class="fa fa-check"></i><b>3.4</b> Load the data</a></li>
<li class="chapter" data-level="3.5" data-path="pca.html"><a href="pca.html#quick-start"><i class="fa fa-check"></i><b>3.5</b> Quick start</a></li>
<li class="chapter" data-level="3.6" data-path="pca.html"><a href="pca.html#to-go-further"><i class="fa fa-check"></i><b>3.6</b> To go further</a><ul>
<li class="chapter" data-level="3.6.1" data-path="pca.html"><a href="pca.html#customize-plots"><i class="fa fa-check"></i><b>3.6.1</b> Customize plots</a></li>
<li class="chapter" data-level="3.6.2" data-path="pca.html"><a href="pca.html#amount-of-variance-explained-and-choice-of-a-number-of-components"><i class="fa fa-check"></i><b>3.6.2</b> Amount of variance explained and choice of a number of components</a></li>
<li class="chapter" data-level="3.6.3" data-path="pca.html"><a href="pca.html#other-useful-plots"><i class="fa fa-check"></i><b>3.6.3</b> Other useful plots</a></li>
</ul></li>
<li class="chapter" data-level="3.7" data-path="pca.html"><a href="pca.html#sPCA"><i class="fa fa-check"></i><b>3.7</b> Variable selection with sparse PCA</a><ul>
<li class="chapter" data-level="3.7.1" data-path="pca.html"><a href="pca.html#biological-question-1"><i class="fa fa-check"></i><b>3.7.1</b> Biological question</a></li>
</ul></li>
<li class="chapter" data-level="3.8" data-path="pca.html"><a href="pca.html#tuning-parameters"><i class="fa fa-check"></i><b>3.8</b> Tuning parameters</a></li>
<li class="chapter" data-level="3.9" data-path="pca.html"><a href="pca.html#additional-resources"><i class="fa fa-check"></i><b>3.9</b> Additional resources</a></li>
<li class="chapter" data-level="3.10" data-path="pca.html"><a href="pca.html#faq"><i class="fa fa-check"></i><b>3.10</b> FAQ</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="plsda.html"><a href="plsda.html"><i class="fa fa-check"></i><b>4</b> PLS - Discriminant Analysis (PLS-DA)</a><ul>
<li class="chapter" data-level="4.1" data-path="plsda.html"><a href="plsda.html#biological-question-2"><i class="fa fa-check"></i><b>4.1</b> Biological question</a></li>
<li class="chapter" data-level="4.2" data-path="plsda.html"><a href="plsda.html#the-srbct-study"><i class="fa fa-check"></i><b>4.2</b> The <code>srbct</code> study</a></li>
<li class="chapter" data-level="4.3" data-path="plsda.html"><a href="plsda.html#principle-of-sparse-pls-da"><i class="fa fa-check"></i><b>4.3</b> Principle of sparse PLS-DA</a></li>
<li class="chapter" data-level="4.4" data-path="plsda.html"><a href="plsda.html#inputs-and-outputs"><i class="fa fa-check"></i><b>4.4</b> Inputs and outputs</a></li>
<li class="chapter" data-level="4.5" data-path="plsda.html"><a href="plsda.html#set-up-the-data"><i class="fa fa-check"></i><b>4.5</b> Set up the data</a></li>
<li class="chapter" data-level="4.6" data-path="plsda.html"><a href="plsda.html#quick-start-1"><i class="fa fa-check"></i><b>4.6</b> Quick start</a></li>
<li class="chapter" data-level="4.7" data-path="plsda.html"><a href="plsda.html#plsda-tgf"><i class="fa fa-check"></i><b>4.7</b> To go further</a><ul>
<li class="chapter" data-level="4.7.1" data-path="plsda.html"><a href="plsda.html#splsda:plotIndiv"><i class="fa fa-check"></i><b>4.7.1</b> Customize the sample plots</a></li>
<li class="chapter" data-level="4.7.2" data-path="plsda.html"><a href="plsda.html#customize-variable-plots"><i class="fa fa-check"></i><b>4.7.2</b> Customize variable plots</a></li>
<li class="chapter" data-level="4.7.3" data-path="plsda.html"><a href="plsda.html#other-useful-plots-1"><i class="fa fa-check"></i><b>4.7.3</b> Other useful plots</a></li>
<li class="chapter" data-level="4.7.4" data-path="plsda.html"><a href="plsda.html#variable-selection-outputs"><i class="fa fa-check"></i><b>4.7.4</b> Variable selection outputs</a></li>
<li class="chapter" data-level="4.7.5" data-path="plsda.html"><a href="plsda.html#tuning:sPLSDA"><i class="fa fa-check"></i><b>4.7.5</b> Tuning parameters and numerical outputs</a></li>
</ul></li>
<li class="chapter" data-level="4.8" data-path="plsda.html"><a href="plsda.html#additional-resources-1"><i class="fa fa-check"></i><b>4.8</b> Additional resources</a></li>
<li class="chapter" data-level="4.9" data-path="plsda.html"><a href="plsda.html#faq-1"><i class="fa fa-check"></i><b>4.9</b> FAQ</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="pls.html"><a href="pls.html"><i class="fa fa-check"></i><b>5</b> Projection to Latent Structure (PLS)</a><ul>
<li class="chapter" data-level="5.1" data-path="pls.html"><a href="pls.html#biological-question-3"><i class="fa fa-check"></i><b>5.1</b> Biological question</a></li>
<li class="chapter" data-level="5.2" data-path="pls.html"><a href="pls.html#the-nutrimouse-study"><i class="fa fa-check"></i><b>5.2</b> The <code>nutrimouse</code> study</a></li>
<li class="chapter" data-level="5.3" data-path="pls.html"><a href="pls.html#principle-of-pls"><i class="fa fa-check"></i><b>5.3</b> Principle of PLS</a></li>
<li class="chapter" data-level="5.4" data-path="pls.html"><a href="pls.html#principle-of-sparse-pls"><i class="fa fa-check"></i><b>5.4</b> Principle of sparse PLS</a></li>
<li class="chapter" data-level="5.5" data-path="pls.html"><a href="pls.html#inputs-and-outputs-1"><i class="fa fa-check"></i><b>5.5</b> Inputs and outputs</a></li>
<li class="chapter" data-level="5.6" data-path="pls.html"><a href="pls.html#set-up-the-data-1"><i class="fa fa-check"></i><b>5.6</b> Set up the data</a></li>
<li class="chapter" data-level="5.7" data-path="pls.html"><a href="pls.html#quick-start-2"><i class="fa fa-check"></i><b>5.7</b> Quick start</a></li>
<li class="chapter" data-level="5.8" data-path="pls.html"><a href="pls.html#pls-tgf"><i class="fa fa-check"></i><b>5.8</b> To go further</a><ul>
<li class="chapter" data-level="5.8.1" data-path="pls.html"><a href="pls.html#pls:plotIndiv"><i class="fa fa-check"></i><b>5.8.1</b> Customize sample plots</a></li>
<li class="chapter" data-level="5.8.2" data-path="pls.html"><a href="pls.html#pls:plotVar"><i class="fa fa-check"></i><b>5.8.2</b> Customize variable plots</a></li>
<li class="chapter" data-level="5.8.3" data-path="pls.html"><a href="pls.html#other-useful-plots-for-data-integration"><i class="fa fa-check"></i><b>5.8.3</b> Other useful plots for data integration</a></li>
<li class="chapter" data-level="5.8.4" data-path="pls.html"><a href="pls.html#variable-selection-outputs-1"><i class="fa fa-check"></i><b>5.8.4</b> Variable selection outputs</a></li>
<li class="chapter" data-level="5.8.5" data-path="pls.html"><a href="pls.html#tuning:PLS"><i class="fa fa-check"></i><b>5.8.5</b> Tuning parameters and numerical outputs</a></li>
<li class="chapter" data-level="5.8.6" data-path="pls.html"><a href="pls.html#PLS:details"><i class="fa fa-check"></i><b>5.8.6</b> PLS modes</a></li>
</ul></li>
<li class="chapter" data-level="5.9" data-path="pls.html"><a href="pls.html#additional-resources-2"><i class="fa fa-check"></i><b>5.9</b> Additional resources</a></li>
<li class="chapter" data-level="5.10" data-path="pls.html"><a href="pls.html#faq-2"><i class="fa fa-check"></i><b>5.10</b> FAQ</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="diablo.html"><a href="diablo.html"><i class="fa fa-check"></i><b>6</b> Multi-block Discriminant Analysis with DIABLO</a><ul>
<li class="chapter" data-level="6.1" data-path="diablo.html"><a href="diablo.html#biological-question-4"><i class="fa fa-check"></i><b>6.1</b> Biological question</a></li>
<li class="chapter" data-level="6.2" data-path="diablo.html"><a href="diablo.html#the-breast.tcga-study"><i class="fa fa-check"></i><b>6.2</b> The <code>breast.TCGA</code> study</a></li>
<li class="chapter" data-level="6.3" data-path="diablo.html"><a href="diablo.html#principle-of-diablo"><i class="fa fa-check"></i><b>6.3</b> Principle of DIABLO</a></li>
<li class="chapter" data-level="6.4" data-path="diablo.html"><a href="diablo.html#inputs-and-outputs-2"><i class="fa fa-check"></i><b>6.4</b> Inputs and outputs</a></li>
<li class="chapter" data-level="6.5" data-path="diablo.html"><a href="diablo.html#set-up-the-data-2"><i class="fa fa-check"></i><b>6.5</b> Set up the data</a></li>
<li class="chapter" data-level="6.6" data-path="diablo.html"><a href="diablo.html#quick-start-3"><i class="fa fa-check"></i><b>6.6</b> Quick start</a></li>
<li class="chapter" data-level="6.7" data-path="diablo.html"><a href="diablo.html#to-go-further-1"><i class="fa fa-check"></i><b>6.7</b> To go further</a><ul>
<li class="chapter" data-level="6.7.1" data-path="diablo.html"><a href="diablo.html#diablo:plotIndiv"><i class="fa fa-check"></i><b>6.7.1</b> Customize sample plots</a></li>
<li class="chapter" data-level="6.7.2" data-path="diablo.html"><a href="diablo.html#diablo:plotVar"><i class="fa fa-check"></i><b>6.7.2</b> Customize variable plots</a></li>
<li class="chapter" data-level="6.7.3" data-path="diablo.html"><a href="diablo.html#other-useful-plots-for-data-integration-1"><i class="fa fa-check"></i><b>6.7.3</b> Other useful plots for data integration</a></li>
</ul></li>
<li class="chapter" data-level="6.8" data-path="diablo.html"><a href="diablo.html#numerical-outputs"><i class="fa fa-check"></i><b>6.8</b> Numerical outputs</a><ul>
<li class="chapter" data-level="6.8.1" data-path="diablo.html"><a href="diablo.html#classification-performance"><i class="fa fa-check"></i><b>6.8.1</b> Classification performance</a></li>
<li class="chapter" data-level="6.8.2" data-path="diablo.html"><a href="diablo.html#auc"><i class="fa fa-check"></i><b>6.8.2</b> AUC</a></li>
<li class="chapter" data-level="6.8.3" data-path="diablo.html"><a href="diablo.html#tuning-parameters-1"><i class="fa fa-check"></i><b>6.8.3</b> Tuning parameters</a></li>
</ul></li>
<li class="chapter" data-level="6.9" data-path="diablo.html"><a href="diablo.html#additional-resources-3"><i class="fa fa-check"></i><b>6.9</b> Additional resources</a></li>
<li class="chapter" data-level="6.10" data-path="diablo.html"><a href="diablo.html#faq-3"><i class="fa fa-check"></i><b>6.10</b> FAQ</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="session-information.html"><a href="session-information.html"><i class="fa fa-check"></i><b>7</b> Session Information</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">mixOmics vignette</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="plsda" class="section level1">
<h1><span class="header-section-number">Chapter 4</span> PLS - Discriminant Analysis (PLS-DA)</h1>
<p><img src="Figures/04-overview-PLSDA-1.png" width="75%"  style="display: block; margin: auto;" /></p>
<div id="biological-question-2" class="section level2">
<h2><span class="header-section-number">4.1</span> Biological question</h2>
<p><span style="color:blue">
<em>I am analysing a single data set (e.g. transcriptomics data) and I would like to classify my samples into known groups and predict the class of new samples. In addition, I am interested in identifying the key variables that drive such discrimination.</em>
</span></p>
</div>
<div id="the-srbct-study" class="section level2">
<h2><span class="header-section-number">4.2</span> The <code>srbct</code> study</h2>
<p>The data are directly available in a processed and normalised format from the package. The Small Round Blue Cell Tumours (SRBCT) dataset from <span class="citation">(Khan et al. <a href="#ref-Kha01">2001</a>)</span> includes the expression levels of 2,308 genes measured on 63 samples. The samples are classified into four classes as follows: 8 Burkitt Lymphoma (BL), 23 Ewing Sarcoma (EWS), 12 neuroblastoma (NB), and 20 rhabdomyosarcoma (RMS).</p>
<p>The srbct dataset contains the following:</p>
<p><strong>$gene:</strong> a data frame with 63 rows and 2308 columns. The expression levels of 2,308 genes in 63 subjects.</p>
<p><strong>$class:</strong> a class vector containing the class tumour of each individual (4 classes in total).</p>
<p><strong>$gene.name:</strong> a data frame with 2,308 rows and 2 columns containing further information on the genes.</p>
<p>More details can be found in <code>?srbct</code>.</p>
<p>To illustrate PLS-DA, we will analyse the gene expression levels of <code>srbct$gene</code> to discriminate the 4 groups of tumours.</p>
</div>
<div id="principle-of-sparse-pls-da" class="section level2">
<h2><span class="header-section-number">4.3</span> Principle of sparse PLS-DA</h2>
<p>Although Partial Least Squares was not originally designed for classification and discrimination problems, it has often been used for that purpose <span class="citation">(Nguyen and Rocke <a href="#ref-Ngu02a">2002</a>; Tan et al. <a href="#ref-Tan04">2004</a>)</span>. The response matrix <code>Y</code> is qualitative and is internally recoded as a dummy block matrix that records the membership of each observation, i.e. each of the response categories are coded via an indicator variable (see <span class="citation">(Rohart, Gautier, et al. <a href="#ref-mixomics">2017</a>)</span> Suppl. Information S1 for an illustration). The PLS regression (now PLS-DA) is then run as if Y was a continuous matrix. This PLS classification trick works well in practice, as demonstrated in many references <span class="citation">(Barker and Rayens <a href="#ref-Bar03">2003</a>; Nguyen and Rocke <a href="#ref-Ngu02a">2002</a>; Boulesteix and Strimmer <a href="#ref-Bou07">2007</a>; Chung and Keles <a href="#ref-Chung10">2010</a>)</span>.</p>
<p>Sparse PLS-DA <span class="citation">(Lê Cao, Boitard, and Besse <a href="#ref-Lec11">2011</a>)</span> performs variable selection and classification in a one-step procedure. sPLS-DA is a special case of sparse PLS described later in <a href="pls.html#pls">5</a>, where <span class="math inline">\(\ell_1\)</span> penalization is applied on the loading vectors associated to the X data set.</p>
</div>
<div id="inputs-and-outputs" class="section level2">
<h2><span class="header-section-number">4.4</span> Inputs and outputs</h2>
<p>We use the following data input matrices: <code>X</code> is a <span class="math inline">\(n \times p\)</span> data matrix, <code>Y</code> is a factor vector of length <span class="math inline">\(n\)</span> that indicates the class of each sample, and <span class="math inline">\(Y^*\)</span> is the associated dummy matrix (<span class="math inline">\(n \times K\)</span>) with <span class="math inline">\(n\)</span> the number of samples (individuals), <span class="math inline">\(p\)</span> the number of variables and <span class="math inline">\(K\)</span> the number of classes. PLS-DA main outputs are:</p>
<ul>
<li><p>A <strong>set of components</strong>, also called latent variables. There are as many components as the chosen
<em>dimension</em> of the PLS-DA model.</p></li>
<li><p>A <strong>set of loading vectors</strong>, which are coefficients assigned to each variable to define each component. These coefficients indicate the importance of each variable in PLS-DA. Importantly, each loading vector is associated to a particular component. Loading vectors are obtained so that the covariance between a linear combination of the variables from X (the X-component) and the factor of interest Y (the <span class="math inline">\(Y^*\)</span>-component) is maximised.</p></li>
<li><p>A <strong>list of selected variables</strong> from <code>X</code> and associated to each component if sPLS-DA is applied.</p></li>
</ul>
</div>
<div id="set-up-the-data" class="section level2">
<h2><span class="header-section-number">4.5</span> Set up the data</h2>
<p>We first load the data from the package. See <a href="start.html#start:upload">2.2</a> to upload your own data.</p>
<p>We will mainly focus on sparse PLS-DA that is more suited for large biological data sets where the aim is to identify molecular signatures, as well as classifying samples. We first set up the data as <code>X</code> expression matrix and <code>Y</code> as a factor indicating the class membership of each sample. We also check that the dimensions are correct and match:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">library</span>(mixOmics)</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="kw">data</span>(srbct)</a>
<a class="sourceLine" id="cb29-3" data-line-number="3">X &lt;-<span class="st"> </span>srbct<span class="op">$</span>gene</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">Y &lt;-<span class="st"> </span>srbct<span class="op">$</span>class </a>
<a class="sourceLine" id="cb29-5" data-line-number="5"><span class="kw">summary</span>(Y) <span class="co">## class summary</span></a></code></pre></div>
<pre><code>## EWS  BL  NB RMS 
##  23   8  12  20</code></pre>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">dim</span>(X) <span class="co">## number of samples and features</span></a></code></pre></div>
<pre><code>## [1]   63 2308</code></pre>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="kw">length</span>(Y) <span class="co">## length of class memebrship factor = number of samples</span></a></code></pre></div>
<pre><code>## [1] 63</code></pre>
</div>
<div id="quick-start-1" class="section level2">
<h2><span class="header-section-number">4.6</span> Quick start</h2>
<p>For a quick start, we arbitrarily set the number of variables to select to 50 on each of the 3 components of PLS-DA (see section <a href="plsda.html#tuning:sPLSDA">4.7.5</a> for tuning these values).</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb35-1" data-line-number="1">MyResult.splsda &lt;-<span class="st"> </span><span class="kw">splsda</span>(X, Y, <span class="dt">keepX =</span> <span class="kw">c</span>(<span class="dv">50</span>,<span class="dv">50</span>)) <span class="co"># 1 Run the method</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="kw">plotIndiv</span>(MyResult.splsda)                          <span class="co"># 2 Plot the samples (coloured by classes automatically)</span></a></code></pre></div>
<p><img src="Figures/04-splsda-and-plots-1.png" width="75%"  style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="kw">plotVar</span>(MyResult.splsda)                            <span class="co"># 3 Plot the variables</span></a></code></pre></div>
<p><img src="Figures/04-splsda-and-plots-2.png" width="75%"  style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb37"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="kw">selectVar</span>(MyResult.splsda, <span class="dt">comp=</span><span class="dv">1</span>)<span class="op">$</span>name             <span class="co"># Selected variables on component 1</span></a></code></pre></div>
<p>As PLS-DA is a supervised method, the sample plot automatically displays the group membership of each sample. We can observe clear discrimination between the BL samples and the others on the first component (x-axis), and EWS vs the others on the second component (y-axis). Remember that this discrimination spanned by the first two PLS-DA components is obtained based on a subset of 100 variables (50 selected on each component).</p>
<p>From the <code>plotIndiv</code> the axis labels indicate the amount of variation explained per component. Note that the interpretation of this amount is <em>not</em> the same as in PCA. In PLS-DA, the aim is to maximise the covariance between <code>X</code> and <code>Y</code>, not only the variance of <code>X</code> as it is the case in PCA!</p>
<p>If you were to run <code>splsda</code> with this minimal code, you would be using the following default values:</p>
<ul>
<li><code>ncomp = 2</code>: the first two PLS components are calculated and are used for graphical outputs;</li>
<li><code>scale = TRUE</code>: data are scaled (variance = 1, strongly advised here);</li>
<li><code>mode = &quot;regression&quot;</code>: by default, a PLS regression mode should be used.</li>
</ul>
<p>PLS-DA without variable selection can be performed as:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb38-1" data-line-number="1">MyResult.plsda &lt;-<span class="st"> </span><span class="kw">plsda</span>(X,Y) <span class="co"># 1 Run the method</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="kw">plotIndiv</span>(MyResult.plsda)    <span class="co"># 2 Plot the samples</span></a></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="kw">plotVar</span>(MyResult.plsda, <span class="dt">cutoff =</span> <span class="fl">0.7</span>)      <span class="co"># 3 Plot the variables</span></a></code></pre></div>
</div>
<div id="plsda-tgf" class="section level2">
<h2><span class="header-section-number">4.7</span> To go further</h2>
<div id="splsda:plotIndiv" class="section level3">
<h3><span class="header-section-number">4.7.1</span> Customize the sample plots</h3>
<p>The sample plots can be improved in various ways. First, if the names of the samples are not meaningful at this stage, they can be replaced by symbols (<code>ind.names=TRUE</code>). Confidence ellipses can be plotted for each sample (<code>ellipse = TRUE</code>, confidence level set to 95% by default, see the argument <code>ellipse.level</code>), Additionally, a star plot displays arrows from each group centroid towards each individual sample (<code>star = TRUE</code>). A 3D plot is also available, see <code>plotIndiv</code> for more details.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">plotIndiv</span>(MyResult.splsda, <span class="dt">ind.names =</span> <span class="ot">FALSE</span>, <span class="dt">legend=</span><span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb40-2" data-line-number="2">          <span class="dt">ellipse =</span> <span class="ot">TRUE</span>, <span class="dt">star =</span> <span class="ot">TRUE</span>, <span class="dt">title =</span> <span class="st">&#39;sPLS-DA on SRBCT&#39;</span>,</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">          <span class="dt">X.label =</span> <span class="st">&#39;PLS-DA 1&#39;</span>, <span class="dt">Y.label =</span> <span class="st">&#39;PLS-DA 2&#39;</span>)</a></code></pre></div>
<p><img src="Figures/04-plsda-plotindiv-args-1.png" width="75%"  style="display: block; margin: auto;" /></p>
</div>
<div id="customize-variable-plots" class="section level3">
<h3><span class="header-section-number">4.7.2</span> Customize variable plots</h3>
<p>The name of the variables can be set to FALSE (<code>var.names=FALSE</code>):</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">plotVar</span>(MyResult.splsda, <span class="dt">var.names=</span><span class="ot">FALSE</span>)</a></code></pre></div>
<p><img src="Figures/04-plsda-plotVar-1.png" width="75%"  style="display: block; margin: auto;" /></p>
<p>In addition, if we had used the non-sparse version of PLS-DA, a cut-off can be set to display only the variables that mostly contribute to the definition of each component. These variables should be located towards the circle of radius 1, far from the centre.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="kw">plotVar</span>(MyResult.plsda, <span class="dt">cutoff=</span><span class="fl">0.7</span>)</a></code></pre></div>
<p><img src="Figures/04-plsda-plotVar-cutoff-1.png" width="75%"  style="display: block; margin: auto;" /></p>
<p>In this particular case, no variable selection was performed. Only the display was altered to show a subset of variables.</p>
</div>
<div id="other-useful-plots-1" class="section level3">
<h3><span class="header-section-number">4.7.3</span> Other useful plots</h3>
<div id="background-prediction" class="section level4">
<h4><span class="header-section-number">4.7.3.1</span> Background prediction</h4>
<p>A ‘prediction’ background can be added to the sample plot by calculating a background surface first, before overlaying the sample plot. See <code>?background.predict</code> for more details. More details about prediction, prediction distances can be found in <span class="citation">(Rohart, Gautier, et al. <a href="#ref-mixomics">2017</a>)</span> in the Suppl. Information.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb43-1" data-line-number="1">background &lt;-<span class="st"> </span><span class="kw">background.predict</span>(MyResult.splsda, <span class="dt">comp.predicted=</span><span class="dv">2</span>,</a>
<a class="sourceLine" id="cb43-2" data-line-number="2">                                <span class="dt">dist =</span> <span class="st">&quot;max.dist&quot;</span>) </a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="kw">plotIndiv</span>(MyResult.splsda, <span class="dt">comp =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">2</span>, <span class="dt">group =</span> srbct<span class="op">$</span>class,</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">          <span class="dt">ind.names =</span> <span class="ot">FALSE</span>, <span class="dt">title =</span> <span class="st">&quot;Maximum distance&quot;</span>,</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">          <span class="dt">legend =</span> <span class="ot">TRUE</span>,  <span class="dt">background =</span> background)</a></code></pre></div>
<p><img src="Figures/04-plsda-background-1.png" width="75%"  style="display: block; margin: auto;" /></p>
</div>
<div id="roc" class="section level4">
<h4><span class="header-section-number">4.7.3.2</span> ROC</h4>
<p>As PLS-DA acts as a classifier, we can plot a ROC Curve to complement the sPLS-DA classification performance results detailed in <a href="plsda.html#tuning:sPLSDA">4.7.5</a>. The AUC is calculated from training cross-validation sets and averaged. Note however that ROC and AUC criteria may not be particularly insightful, or may not be in full agreement with the PLSDA performance, as the prediction threshold in PLS-DA is based on specified distance as described in <span class="citation">(Rohart, Gautier, et al. <a href="#ref-mixomics">2017</a>)</span>.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb44-1" data-line-number="1">auc.plsda &lt;-<span class="st"> </span><span class="kw">auroc</span>(MyResult.splsda)</a></code></pre></div>
<p><img src="Figures/04-auroc-1.png" width="75%"  style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="variable-selection-outputs" class="section level3">
<h3><span class="header-section-number">4.7.4</span> Variable selection outputs</h3>
<p>First, note that the number of variables to select on each component does not need to be identical on each component, for example:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb45-1" data-line-number="1">MyResult.splsda2 &lt;-<span class="st"> </span><span class="kw">splsda</span>(X,Y, <span class="dt">ncomp=</span><span class="dv">3</span>, <span class="dt">keepX=</span><span class="kw">c</span>(<span class="dv">15</span>,<span class="dv">10</span>,<span class="dv">5</span>))</a></code></pre></div>
<p>Selected variables are listed in the <code>selectVar</code> function:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="kw">selectVar</span>(MyResult.splsda2, <span class="dt">comp=</span><span class="dv">1</span>)<span class="op">$</span>value</a></code></pre></div>
<pre><code>##        value.var
## g123  0.53516982
## g846  0.41271455
## g335  0.30309695
## g1606 0.30194141
## g836  0.29365241
## g783  0.26329876
## g758  0.25826903
## g1386 0.23702577
## g1158 0.15283961
## g585  0.13838913
## g589  0.12738682
## g1387 0.12202390
## g1884 0.08458869
## g1295 0.03150351
## g1036 0.00224886</code></pre>
<p>and can be visualised in <code>plotLoadings</code> with the arguments <code>contrib = 'max'</code> that is going to assign to each variable bar the sample group colour for which the mean (<code>method = 'mean'</code>) is maximum. See <code>example(plotLoadings)</code> for other options (e.g. min, median)</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">plotLoadings</span>(MyResult.splsda2, <span class="dt">contrib =</span> <span class="st">&#39;max&#39;</span>, <span class="dt">method =</span> <span class="st">&#39;mean&#39;</span>)</a></code></pre></div>
<p><img src="Figures/04-splsda-plotLoadings-1.png" width="75%"  style="display: block; margin: auto;" /></p>
<p>Interestingly from this plot, we can see that all selected variables on component 1 are highly expressed in the BL (orange) class. Setting <code>contrib = 'min'</code> would highlight that those variables are lowly expressed in the NB grey class, which makes sense when we look at the sample plot.</p>
<p>Since 4 classes are being discriminated here, samples plots in 3d may help interpretation (available in the <code>html</code> vignette only):</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">plotIndiv</span>(MyResult.splsda2, <span class="dt">style=</span><span class="st">&quot;3d&quot;</span>)</a></code></pre></div>
<script>/*
* Copyright (C) 2009 Apple Inc. All Rights Reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
* PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Copyright (2016) Duncan Murdoch - fixed CanvasMatrix4.ortho,
* cleaned up.
*/
/*
CanvasMatrix4 class
This class implements a 4x4 matrix. It has functions which
duplicate the functionality of the OpenGL matrix stack and
glut functions.
IDL:
[
Constructor(in CanvasMatrix4 matrix),           // copy passed matrix into new CanvasMatrix4
Constructor(in sequence<float> array)           // create new CanvasMatrix4 with 16 floats (row major)
Constructor()                                   // create new CanvasMatrix4 with identity matrix
]
interface CanvasMatrix4 {
attribute float m11;
attribute float m12;
attribute float m13;
attribute float m14;
attribute float m21;
attribute float m22;
attribute float m23;
attribute float m24;
attribute float m31;
attribute float m32;
attribute float m33;
attribute float m34;
attribute float m41;
attribute float m42;
attribute float m43;
attribute float m44;
void load(in CanvasMatrix4 matrix);                 // copy the values from the passed matrix
void load(in sequence<float> array);                // copy 16 floats into the matrix
sequence<float> getAsArray();                       // return the matrix as an array of 16 floats
WebGLFloatArray getAsCanvasFloatArray();           // return the matrix as a WebGLFloatArray with 16 values
void makeIdentity();                                // replace the matrix with identity
void transpose();                                   // replace the matrix with its transpose
void invert();                                      // replace the matrix with its inverse
void translate(in float x, in float y, in float z); // multiply the matrix by passed translation values on the right
void scale(in float x, in float y, in float z);     // multiply the matrix by passed scale values on the right
void rotate(in float angle,                         // multiply the matrix by passed rotation values on the right
in float x, in float y, in float z);    // (angle is in degrees)
void multRight(in CanvasMatrix matrix);             // multiply the matrix by the passed matrix on the right
void multLeft(in CanvasMatrix matrix);              // multiply the matrix by the passed matrix on the left
void ortho(in float left, in float right,           // multiply the matrix by the passed ortho values on the right
in float bottom, in float top,
in float near, in float far);
void frustum(in float left, in float right,         // multiply the matrix by the passed frustum values on the right
in float bottom, in float top,
in float near, in float far);
void perspective(in float fovy, in float aspect,    // multiply the matrix by the passed perspective values on the right
in float zNear, in float zFar);
void lookat(in float eyex, in float eyey, in float eyez,    // multiply the matrix by the passed lookat
in float ctrx, in float ctry, in float ctrz,    // values on the right
in float upx, in float upy, in float upz);
}
*/
CanvasMatrix4 = function(m)
{
if (typeof m == 'object') {
if ("length" in m && m.length >= 16) {
this.load(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
return;
}
else if (m instanceof CanvasMatrix4) {
this.load(m);
return;
}
}
this.makeIdentity();
};
CanvasMatrix4.prototype.load = function()
{
if (arguments.length == 1 && typeof arguments[0] == 'object') {
var matrix = arguments[0];
if ("length" in matrix && matrix.length == 16) {
this.m11 = matrix[0];
this.m12 = matrix[1];
this.m13 = matrix[2];
this.m14 = matrix[3];
this.m21 = matrix[4];
this.m22 = matrix[5];
this.m23 = matrix[6];
this.m24 = matrix[7];
this.m31 = matrix[8];
this.m32 = matrix[9];
this.m33 = matrix[10];
this.m34 = matrix[11];
this.m41 = matrix[12];
this.m42 = matrix[13];
this.m43 = matrix[14];
this.m44 = matrix[15];
return;
}
if (arguments[0] instanceof CanvasMatrix4) {
this.m11 = matrix.m11;
this.m12 = matrix.m12;
this.m13 = matrix.m13;
this.m14 = matrix.m14;
this.m21 = matrix.m21;
this.m22 = matrix.m22;
this.m23 = matrix.m23;
this.m24 = matrix.m24;
this.m31 = matrix.m31;
this.m32 = matrix.m32;
this.m33 = matrix.m33;
this.m34 = matrix.m34;
this.m41 = matrix.m41;
this.m42 = matrix.m42;
this.m43 = matrix.m43;
this.m44 = matrix.m44;
return;
}
}
this.makeIdentity();
};
CanvasMatrix4.prototype.getAsArray = function()
{
return [
this.m11, this.m12, this.m13, this.m14,
this.m21, this.m22, this.m23, this.m24,
this.m31, this.m32, this.m33, this.m34,
this.m41, this.m42, this.m43, this.m44
];
};
CanvasMatrix4.prototype.getAsWebGLFloatArray = function()
{
return new WebGLFloatArray(this.getAsArray());
};
CanvasMatrix4.prototype.makeIdentity = function()
{
this.m11 = 1;
this.m12 = 0;
this.m13 = 0;
this.m14 = 0;
this.m21 = 0;
this.m22 = 1;
this.m23 = 0;
this.m24 = 0;
this.m31 = 0;
this.m32 = 0;
this.m33 = 1;
this.m34 = 0;
this.m41 = 0;
this.m42 = 0;
this.m43 = 0;
this.m44 = 1;
};
CanvasMatrix4.prototype.transpose = function()
{
var tmp = this.m12;
this.m12 = this.m21;
this.m21 = tmp;
tmp = this.m13;
this.m13 = this.m31;
this.m31 = tmp;
tmp = this.m14;
this.m14 = this.m41;
this.m41 = tmp;
tmp = this.m23;
this.m23 = this.m32;
this.m32 = tmp;
tmp = this.m24;
this.m24 = this.m42;
this.m42 = tmp;
tmp = this.m34;
this.m34 = this.m43;
this.m43 = tmp;
};
CanvasMatrix4.prototype.invert = function()
{
// Calculate the 4x4 determinant
// If the determinant is zero,
// then the inverse matrix is not unique.
var det = this._determinant4x4();
if (Math.abs(det) < 1e-8)
return null;
this._makeAdjoint();
// Scale the adjoint matrix to get the inverse
this.m11 /= det;
this.m12 /= det;
this.m13 /= det;
this.m14 /= det;
this.m21 /= det;
this.m22 /= det;
this.m23 /= det;
this.m24 /= det;
this.m31 /= det;
this.m32 /= det;
this.m33 /= det;
this.m34 /= det;
this.m41 /= det;
this.m42 /= det;
this.m43 /= det;
this.m44 /= det;
};
CanvasMatrix4.prototype.translate = function(x,y,z)
{
if (x === undefined)
x = 0;
if (y === undefined)
y = 0;
if (z === undefined)
z = 0;
var matrix = new CanvasMatrix4();
matrix.m41 = x;
matrix.m42 = y;
matrix.m43 = z;
this.multRight(matrix);
};
CanvasMatrix4.prototype.scale = function(x,y,z)
{
if (x === undefined)
x = 1;
if (z === undefined) {
if (y === undefined) {
y = x;
z = x;
}
else
z = 1;
}
else if (y === undefined)
y = x;
var matrix = new CanvasMatrix4();
matrix.m11 = x;
matrix.m22 = y;
matrix.m33 = z;
this.multRight(matrix);
};
CanvasMatrix4.prototype.rotate = function(angle,x,y,z)
{
// angles are in degrees. Switch to radians
angle = angle / 180 * Math.PI;
angle /= 2;
var sinA = Math.sin(angle);
var cosA = Math.cos(angle);
var sinA2 = sinA * sinA;
// normalize
var length = Math.sqrt(x * x + y * y + z * z);
if (length === 0) {
// bad vector, just use something reasonable
x = 0;
y = 0;
z = 1;
} else if (length != 1) {
x /= length;
y /= length;
z /= length;
}
var mat = new CanvasMatrix4();
// optimize case where axis is along major axis
if (x == 1 && y === 0 && z === 0) {
mat.m11 = 1;
mat.m12 = 0;
mat.m13 = 0;
mat.m21 = 0;
mat.m22 = 1 - 2 * sinA2;
mat.m23 = 2 * sinA * cosA;
mat.m31 = 0;
mat.m32 = -2 * sinA * cosA;
mat.m33 = 1 - 2 * sinA2;
mat.m14 = mat.m24 = mat.m34 = 0;
mat.m41 = mat.m42 = mat.m43 = 0;
mat.m44 = 1;
} else if (x === 0 && y == 1 && z === 0) {
mat.m11 = 1 - 2 * sinA2;
mat.m12 = 0;
mat.m13 = -2 * sinA * cosA;
mat.m21 = 0;
mat.m22 = 1;
mat.m23 = 0;
mat.m31 = 2 * sinA * cosA;
mat.m32 = 0;
mat.m33 = 1 - 2 * sinA2;
mat.m14 = mat.m24 = mat.m34 = 0;
mat.m41 = mat.m42 = mat.m43 = 0;
mat.m44 = 1;
} else if (x === 0 && y === 0 && z == 1) {
mat.m11 = 1 - 2 * sinA2;
mat.m12 = 2 * sinA * cosA;
mat.m13 = 0;
mat.m21 = -2 * sinA * cosA;
mat.m22 = 1 - 2 * sinA2;
mat.m23 = 0;
mat.m31 = 0;
mat.m32 = 0;
mat.m33 = 1;
mat.m14 = mat.m24 = mat.m34 = 0;
mat.m41 = mat.m42 = mat.m43 = 0;
mat.m44 = 1;
} else {
var x2 = x*x;
var y2 = y*y;
var z2 = z*z;
mat.m11 = 1 - 2 * (y2 + z2) * sinA2;
mat.m12 = 2 * (x * y * sinA2 + z * sinA * cosA);
mat.m13 = 2 * (x * z * sinA2 - y * sinA * cosA);
mat.m21 = 2 * (y * x * sinA2 - z * sinA * cosA);
mat.m22 = 1 - 2 * (z2 + x2) * sinA2;
mat.m23 = 2 * (y * z * sinA2 + x * sinA * cosA);
mat.m31 = 2 * (z * x * sinA2 + y * sinA * cosA);
mat.m32 = 2 * (z * y * sinA2 - x * sinA * cosA);
mat.m33 = 1 - 2 * (x2 + y2) * sinA2;
mat.m14 = mat.m24 = mat.m34 = 0;
mat.m41 = mat.m42 = mat.m43 = 0;
mat.m44 = 1;
}
this.multRight(mat);
};
CanvasMatrix4.prototype.multRight = function(mat)
{
var m11 = (this.m11 * mat.m11 + this.m12 * mat.m21 +
this.m13 * mat.m31 + this.m14 * mat.m41);
var m12 = (this.m11 * mat.m12 + this.m12 * mat.m22 +
this.m13 * mat.m32 + this.m14 * mat.m42);
var m13 = (this.m11 * mat.m13 + this.m12 * mat.m23 +
this.m13 * mat.m33 + this.m14 * mat.m43);
var m14 = (this.m11 * mat.m14 + this.m12 * mat.m24 +
this.m13 * mat.m34 + this.m14 * mat.m44);
var m21 = (this.m21 * mat.m11 + this.m22 * mat.m21 +
this.m23 * mat.m31 + this.m24 * mat.m41);
var m22 = (this.m21 * mat.m12 + this.m22 * mat.m22 +
this.m23 * mat.m32 + this.m24 * mat.m42);
var m23 = (this.m21 * mat.m13 + this.m22 * mat.m23 +
this.m23 * mat.m33 + this.m24 * mat.m43);
var m24 = (this.m21 * mat.m14 + this.m22 * mat.m24 +
this.m23 * mat.m34 + this.m24 * mat.m44);
var m31 = (this.m31 * mat.m11 + this.m32 * mat.m21 +
this.m33 * mat.m31 + this.m34 * mat.m41);
var m32 = (this.m31 * mat.m12 + this.m32 * mat.m22 +
this.m33 * mat.m32 + this.m34 * mat.m42);
var m33 = (this.m31 * mat.m13 + this.m32 * mat.m23 +
this.m33 * mat.m33 + this.m34 * mat.m43);
var m34 = (this.m31 * mat.m14 + this.m32 * mat.m24 +
this.m33 * mat.m34 + this.m34 * mat.m44);
var m41 = (this.m41 * mat.m11 + this.m42 * mat.m21 +
this.m43 * mat.m31 + this.m44 * mat.m41);
var m42 = (this.m41 * mat.m12 + this.m42 * mat.m22 +
this.m43 * mat.m32 + this.m44 * mat.m42);
var m43 = (this.m41 * mat.m13 + this.m42 * mat.m23 +
this.m43 * mat.m33 + this.m44 * mat.m43);
var m44 = (this.m41 * mat.m14 + this.m42 * mat.m24 +
this.m43 * mat.m34 + this.m44 * mat.m44);
this.m11 = m11;
this.m12 = m12;
this.m13 = m13;
this.m14 = m14;
this.m21 = m21;
this.m22 = m22;
this.m23 = m23;
this.m24 = m24;
this.m31 = m31;
this.m32 = m32;
this.m33 = m33;
this.m34 = m34;
this.m41 = m41;
this.m42 = m42;
this.m43 = m43;
this.m44 = m44;
};
CanvasMatrix4.prototype.multLeft = function(mat)
{
var m11 = (mat.m11 * this.m11 + mat.m12 * this.m21 +
mat.m13 * this.m31 + mat.m14 * this.m41);
var m12 = (mat.m11 * this.m12 + mat.m12 * this.m22 +
mat.m13 * this.m32 + mat.m14 * this.m42);
var m13 = (mat.m11 * this.m13 + mat.m12 * this.m23 +
mat.m13 * this.m33 + mat.m14 * this.m43);
var m14 = (mat.m11 * this.m14 + mat.m12 * this.m24 +
mat.m13 * this.m34 + mat.m14 * this.m44);
var m21 = (mat.m21 * this.m11 + mat.m22 * this.m21 +
mat.m23 * this.m31 + mat.m24 * this.m41);
var m22 = (mat.m21 * this.m12 + mat.m22 * this.m22 +
mat.m23 * this.m32 + mat.m24 * this.m42);
var m23 = (mat.m21 * this.m13 + mat.m22 * this.m23 +
mat.m23 * this.m33 + mat.m24 * this.m43);
var m24 = (mat.m21 * this.m14 + mat.m22 * this.m24 +
mat.m23 * this.m34 + mat.m24 * this.m44);
var m31 = (mat.m31 * this.m11 + mat.m32 * this.m21 +
mat.m33 * this.m31 + mat.m34 * this.m41);
var m32 = (mat.m31 * this.m12 + mat.m32 * this.m22 +
mat.m33 * this.m32 + mat.m34 * this.m42);
var m33 = (mat.m31 * this.m13 + mat.m32 * this.m23 +
mat.m33 * this.m33 + mat.m34 * this.m43);
var m34 = (mat.m31 * this.m14 + mat.m32 * this.m24 +
mat.m33 * this.m34 + mat.m34 * this.m44);
var m41 = (mat.m41 * this.m11 + mat.m42 * this.m21 +
mat.m43 * this.m31 + mat.m44 * this.m41);
var m42 = (mat.m41 * this.m12 + mat.m42 * this.m22 +
mat.m43 * this.m32 + mat.m44 * this.m42);
var m43 = (mat.m41 * this.m13 + mat.m42 * this.m23 +
mat.m43 * this.m33 + mat.m44 * this.m43);
var m44 = (mat.m41 * this.m14 + mat.m42 * this.m24 +
mat.m43 * this.m34 + mat.m44 * this.m44);
this.m11 = m11;
this.m12 = m12;
this.m13 = m13;
this.m14 = m14;
this.m21 = m21;
this.m22 = m22;
this.m23 = m23;
this.m24 = m24;
this.m31 = m31;
this.m32 = m32;
this.m33 = m33;
this.m34 = m34;
this.m41 = m41;
this.m42 = m42;
this.m43 = m43;
this.m44 = m44;
};
CanvasMatrix4.prototype.ortho = function(left, right, bottom, top, near, far)
{
var tx = (left + right) / (left - right);
var ty = (top + bottom) / (bottom - top);
var tz = (far + near) / (near - far);
var matrix = new CanvasMatrix4();
matrix.m11 = 2 / (right - left);
matrix.m12 = 0;
matrix.m13 = 0;
matrix.m14 = 0;
matrix.m21 = 0;
matrix.m22 = 2 / (top - bottom);
matrix.m23 = 0;
matrix.m24 = 0;
matrix.m31 = 0;
matrix.m32 = 0;
matrix.m33 = -2 / (far - near);
matrix.m34 = 0;
matrix.m41 = tx;
matrix.m42 = ty;
matrix.m43 = tz;
matrix.m44 = 1;
this.multRight(matrix);
};
CanvasMatrix4.prototype.frustum = function(left, right, bottom, top, near, far)
{
var matrix = new CanvasMatrix4();
var A = (right + left) / (right - left);
var B = (top + bottom) / (top - bottom);
var C = -(far + near) / (far - near);
var D = -(2 * far * near) / (far - near);
matrix.m11 = (2 * near) / (right - left);
matrix.m12 = 0;
matrix.m13 = 0;
matrix.m14 = 0;
matrix.m21 = 0;
matrix.m22 = 2 * near / (top - bottom);
matrix.m23 = 0;
matrix.m24 = 0;
matrix.m31 = A;
matrix.m32 = B;
matrix.m33 = C;
matrix.m34 = -1;
matrix.m41 = 0;
matrix.m42 = 0;
matrix.m43 = D;
matrix.m44 = 0;
this.multRight(matrix);
};
CanvasMatrix4.prototype.perspective = function(fovy, aspect, zNear, zFar)
{
var top = Math.tan(fovy * Math.PI / 360) * zNear;
var bottom = -top;
var left = aspect * bottom;
var right = aspect * top;
this.frustum(left, right, bottom, top, zNear, zFar);
};
CanvasMatrix4.prototype.lookat = function(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz)
{
var matrix = new CanvasMatrix4();
// Make rotation matrix
// Z vector
var zx = eyex - centerx;
var zy = eyey - centery;
var zz = eyez - centerz;
var mag = Math.sqrt(zx * zx + zy * zy + zz * zz);
if (mag) {
zx /= mag;
zy /= mag;
zz /= mag;
}
// Y vector
var yx = upx;
var yy = upy;
var yz = upz;
// X vector = Y cross Z
xx =  yy * zz - yz * zy;
xy = -yx * zz + yz * zx;
xz =  yx * zy - yy * zx;
// Recompute Y = Z cross X
yx = zy * xz - zz * xy;
yy = -zx * xz + zz * xx;
yx = zx * xy - zy * xx;
// cross product gives area of parallelogram, which is < 1.0 for
// non-perpendicular unit-length vectors; so normalize x, y here
mag = Math.sqrt(xx * xx + xy * xy + xz * xz);
if (mag) {
xx /= mag;
xy /= mag;
xz /= mag;
}
mag = Math.sqrt(yx * yx + yy * yy + yz * yz);
if (mag) {
yx /= mag;
yy /= mag;
yz /= mag;
}
matrix.m11 = xx;
matrix.m12 = xy;
matrix.m13 = xz;
matrix.m14 = 0;
matrix.m21 = yx;
matrix.m22 = yy;
matrix.m23 = yz;
matrix.m24 = 0;
matrix.m31 = zx;
matrix.m32 = zy;
matrix.m33 = zz;
matrix.m34 = 0;
matrix.m41 = 0;
matrix.m42 = 0;
matrix.m43 = 0;
matrix.m44 = 1;
matrix.translate(-eyex, -eyey, -eyez);
this.multRight(matrix);
};
// Support functions
CanvasMatrix4.prototype._determinant2x2 = function(a, b, c, d)
{
return a * d - b * c;
};
CanvasMatrix4.prototype._determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3)
{
return a1 * this._determinant2x2(b2, b3, c2, c3) -
b1 * this._determinant2x2(a2, a3, c2, c3) +
c1 * this._determinant2x2(a2, a3, b2, b3);
};
CanvasMatrix4.prototype._determinant4x4 = function()
{
var a1 = this.m11;
var b1 = this.m12;
var c1 = this.m13;
var d1 = this.m14;
var a2 = this.m21;
var b2 = this.m22;
var c2 = this.m23;
var d2 = this.m24;
var a3 = this.m31;
var b3 = this.m32;
var c3 = this.m33;
var d3 = this.m34;
var a4 = this.m41;
var b4 = this.m42;
var c4 = this.m43;
var d4 = this.m44;
return a1 * this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
b1 * this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
c1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
d1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};
CanvasMatrix4.prototype._makeAdjoint = function()
{
var a1 = this.m11;
var b1 = this.m12;
var c1 = this.m13;
var d1 = this.m14;
var a2 = this.m21;
var b2 = this.m22;
var c2 = this.m23;
var d2 = this.m24;
var a3 = this.m31;
var b3 = this.m32;
var c3 = this.m33;
var d3 = this.m34;
var a4 = this.m41;
var b4 = this.m42;
var c4 = this.m43;
var d4 = this.m44;
// Row column labeling reversed since we transpose rows & columns
this.m11  =   this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
this.m21  = - this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
this.m31  =   this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
this.m41  = - this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
this.m12  = - this._determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
this.m22  =   this._determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
this.m32  = - this._determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
this.m42  =   this._determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);
this.m13  =   this._determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
this.m23  = - this._determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
this.m33  =   this._determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
this.m43  = - this._determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);
this.m14  = - this._determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
this.m24  =   this._determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
this.m34  = - this._determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
this.m44  =   this._determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
};</script>
<script>// To generate the help pages for this library, use
// jsdoc --destination ../../../doc/rglwidgetClass --template ~/node_modules/jsdoc-baseline rglClass.src.js
// To validate, use
// setwd(".../inst/htmlwidgets/lib/rglClass")
// hints <- js::jshint(readLines("rglClass.src.js"))
// hints[, c("line", "reason")]
/**
* The class of an rgl widget
* @class
*/
rglwidgetClass = function() {
this.canvas = null;
this.userMatrix = new CanvasMatrix4();
this.types = [];
this.prMatrix = new CanvasMatrix4();
this.mvMatrix = new CanvasMatrix4();
this.vp = null;
this.prmvMatrix = null;
this.origs = null;
this.gl = null;
this.scene = null;
this.select = {state: "inactive", subscene: null, region: {p1: {x:0, y:0}, p2: {x:0, y:0}}};
this.drawing = false;
};
/**
* Multiply matrix by vector
* @returns {number[]}
* @param M {number[][]} Left operand
* @param v {number[]} Right operand
*/
rglwidgetClass.prototype.multMV = function(M, v) {
return [ M.m11 * v[0] + M.m12 * v[1] + M.m13 * v[2] + M.m14 * v[3],
M.m21 * v[0] + M.m22 * v[1] + M.m23 * v[2] + M.m24 * v[3],
M.m31 * v[0] + M.m32 * v[1] + M.m33 * v[2] + M.m34 * v[3],
M.m41 * v[0] + M.m42 * v[1] + M.m43 * v[2] + M.m44 * v[3]
];
};
/**
* Multiply row vector by Matrix
* @returns {number[]}
* @param v {number[]} left operand
* @param M {number[][]} right operand
*/
rglwidgetClass.prototype.multVM = function(v, M) {
return [ M.m11 * v[0] + M.m21 * v[1] + M.m31 * v[2] + M.m41 * v[3],
M.m12 * v[0] + M.m22 * v[1] + M.m32 * v[2] + M.m42 * v[3],
M.m13 * v[0] + M.m23 * v[1] + M.m33 * v[2] + M.m43 * v[3],
M.m14 * v[0] + M.m24 * v[1] + M.m34 * v[2] + M.m44 * v[3]
];
};
/**
* Euclidean length of a vector
* @returns {number}
* @param v {number[]}
*/
rglwidgetClass.prototype.vlen = function(v) {
return Math.sqrt(this.dotprod(v, v));
};
/**
* Dot product of two vectors
* @instance rglwidgetClass
* @returns {number}
* @param a {number[]}
* @param b {number[]}
*/
rglwidgetClass.prototype.dotprod = function(a, b) {
return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
};
/**
* Cross product of two vectors
* @returns {number[]}
* @param a {number[]}
* @param b {number[]}
*/
rglwidgetClass.prototype.xprod = function(a, b) {
return [a[1]*b[2] - a[2]*b[1],
a[2]*b[0] - a[0]*b[2],
a[0]*b[1] - a[1]*b[0]];
};
/**
* Bind vectors or matrices by columns
* @returns {number[][]}
* @param a {number[]|number[][]}
* @param b {number[]|number[][]}
*/
rglwidgetClass.prototype.cbind = function(a, b) {
if (b.length < a.length)
b = this.repeatToLen(b, a.length);
else if (a.length < b.length)
a = this.repeatToLen(a, b.length);
return a.map(function(currentValue, index, array) {
return currentValue.concat(b[index]);
});
};
/**
* Swap elements
* @returns {any[]}
* @param a {any[]}
* @param i {number} Element to swap
* @param j {number} Other element to swap
*/
rglwidgetClass.prototype.swap = function(a, i, j) {
var temp = a[i];
a[i] = a[j];
a[j] = temp;
};
/**
* Flatten a matrix into a vector
* @returns {any[]}
* @param a {any[][]}
*/
rglwidgetClass.prototype.flatten = function(arr, result) {
var value;
if (typeof result === "undefined") result = [];
for (var i = 0, length = arr.length; i < length; i++) {
value = arr[i];
if (Array.isArray(value)) {
this.flatten(value, result);
} else {
result.push(value);
}
}
return result;
};
/**
* set element of 1d or 2d array as if it was flattened.
* Column major, zero based!
* @returns {any[]|any[][]}
* @param {any[]|any[][]} a - array
* @param {number} i - element
* @param {any} value
*/
rglwidgetClass.prototype.setElement = function(a, i, value) {
if (Array.isArray(a[0])) {
var dim = a.length,
col = Math.floor(i/dim),
row = i % dim;
a[row][col] = value;
} else {
a[i] = value;
}
};
/**
* Transpose an array
* @returns {any[][]}
* @param {any[][]} a
*/
rglwidgetClass.prototype.transpose = function(a) {
var newArray = [],
n = a.length,
m = a[0].length,
i;
for(i = 0; i < m; i++){
newArray.push([]);
}
for(i = 0; i < n; i++){
for(var j = 0; j < m; j++){
newArray[j].push(a[i][j]);
}
}
return newArray;
};
/**
* Calculate sum of squares of a numeric vector
* @returns {number}
* @param {number[]} x
*/
rglwidgetClass.prototype.sumsq = function(x) {
var result = 0, i;
for (i=0; i < x.length; i++)
result += x[i]*x[i];
return result;
};
/**
* Convert a matrix to a CanvasMatrix4
* @returns {CanvasMatrix4}
* @param {number[][]|number[]} mat
*/
rglwidgetClass.prototype.toCanvasMatrix4 = function(mat) {
if (mat instanceof CanvasMatrix4)
return mat;
var result = new CanvasMatrix4();
mat = this.flatten(this.transpose(mat));
result.load(mat);
return result;
};
/**
* Convert an R-style numeric colour string to an rgb vector
* @returns {number[]}
* @param {string} s
*/
rglwidgetClass.prototype.stringToRgb = function(s) {
s = s.replace("#", "");
var bigint = parseInt(s, 16);
return [((bigint >> 16) & 255)/255,
((bigint >> 8) & 255)/255,
(bigint & 255)/255];
};
/**
* Take a component-by-component product of two 3 vectors
* @returns {number[]}
* @param {number[]} x
* @param {number[]} y
*/
rglwidgetClass.prototype.componentProduct = function(x, y) {
if (typeof y === "undefined") {
this.alertOnce("Bad arg to componentProduct");
}
var result = new Float32Array(3), i;
for (i = 0; i<3; i++)
result[i] = x[i]*y[i];
return result;
};
/**
* Get next higher power of two
* @returns { number }
* @param { number } value - input value
*/
rglwidgetClass.prototype.getPowerOfTwo = function(value) {
var pow = 1;
while(pow<value) {
pow *= 2;
}
return pow;
};
/**
* Unique entries
* @returns { any[] }
* @param { any[] } arr - An array
*/
rglwidgetClass.prototype.unique = function(arr) {
arr = [].concat(arr);
return arr.filter(function(value, index, self) {
return self.indexOf(value) === index;
});
};
/**
* Shallow compare of arrays
* @returns { boolean }
* @param { any[] } a - An array
* @param { any[] } b - Another array
*/
rglwidgetClass.prototype.equalArrays = function(a, b) {
return a === b || (a && b &&
a.length === b.length &&
a.every(function(v, i) {return v === b[i];}));
};
/**
* Repeat an array to a desired length
* @returns {any[]}
* @param {any | any[]} arr The input array
* @param {number} len The desired output length
*/
rglwidgetClass.prototype.repeatToLen = function(arr, len) {
arr = [].concat(arr);
while (arr.length < len/2)
arr = arr.concat(arr);
return arr.concat(arr.slice(0, len - arr.length));
};
/**
* Give a single alert message, not to be repeated.
* @param {string} msg  The message to give.
*/
rglwidgetClass.prototype.alertOnce = function(msg) {
if (typeof this.alerted !== "undefined")
return;
this.alerted = true;
alert(msg);
};
rglwidgetClass.prototype.f_is_lit = 1;
rglwidgetClass.prototype.f_is_smooth = 2;
rglwidgetClass.prototype.f_has_texture = 4;
rglwidgetClass.prototype.f_depth_sort = 8;
rglwidgetClass.prototype.f_fixed_quads = 16;
rglwidgetClass.prototype.f_is_transparent = 32;
rglwidgetClass.prototype.f_is_lines = 64;
rglwidgetClass.prototype.f_sprites_3d = 128;
rglwidgetClass.prototype.f_sprite_3d = 256;
rglwidgetClass.prototype.f_is_subscene = 512;
rglwidgetClass.prototype.f_is_clipplanes = 1024;
rglwidgetClass.prototype.f_fixed_size = 2048;
rglwidgetClass.prototype.f_is_points = 4096;
rglwidgetClass.prototype.f_is_twosided = 8192;
rglwidgetClass.prototype.f_fat_lines = 16384;
rglwidgetClass.prototype.f_is_brush = 32768;
/**
* Which list does a particular id come from?
* @returns { string }
* @param {number} id The id to look up.
*/
rglwidgetClass.prototype.whichList = function(id) {
var obj = this.getObj(id),
flags = obj.flags;
if (obj.type === "light")
return "lights";
if (flags & this.f_is_subscene)
return "subscenes";
if (flags & this.f_is_clipplanes)
return "clipplanes";
if (flags & this.f_is_transparent)
return "transparent";
return "opaque";
};
/**
* Get an object by id number.
* @returns { Object }
* @param {number} id
*/
rglwidgetClass.prototype.getObj = function(id) {
if (typeof id !== "number") {
this.alertOnce("getObj id is "+typeof id);
}
return this.scene.objects[id];
};
/**
* Get ids of a particular type from a subscene or the whole scene
* @returns { number[] }
* @param {string} type What type of object?
* @param {number} subscene  Which subscene?  If not given, find in the whole scene
*/
rglwidgetClass.prototype.getIdsByType = function(type, subscene) {
var
result = [], i, self = this;
if (typeof subscene === "undefined") {
Object.keys(this.scene.objects).forEach(
function(key) {
key = parseInt(key, 10);
if (self.getObj(key).type === type)
result.push(key);
});
} else {
ids = this.getObj(subscene).objects;
for (i=0; i < ids.length; i++) {
if (this.getObj(ids[i]).type === type) {
result.push(ids[i]);
}
}
}
return result;
};
/**
* Get a particular material property for an id
* @returns { any }
* @param {number} id  Which object?
* @param {string} property Which material property?
*/
rglwidgetClass.prototype.getMaterial = function(id, property) {
var obj = this.getObj(id), mat;
if (typeof obj.material === "undefined")
console.error("material undefined");
mat = obj.material[property];
if (typeof mat === "undefined")
mat = this.scene.material[property];
return mat;
};
/**
* Is a particular id in a subscene?
* @returns { boolean }
* @param {number} id Which id?
* @param {number} subscene Which subscene id?
*/
rglwidgetClass.prototype.inSubscene = function(id, subscene) {
return this.getObj(subscene).objects.indexOf(id) > -1;
};
/**
* Add an id to a subscene.
* @param {number} id Which id?
* @param {number} subscene Which subscene id?
*/
rglwidgetClass.prototype.addToSubscene = function(id, subscene) {
var thelist,
thesub = this.getObj(subscene),
ids = [id],
obj = this.getObj(id), i;
if (typeof obj != "undefined" && typeof (obj.newIds) !== "undefined") {
ids = ids.concat(obj.newIds);
}
thesub.objects = [].concat(thesub.objects);
for (i = 0; i < ids.length; i++) {
id = ids[i];
if (thesub.objects.indexOf(id) == -1) {
thelist = this.whichList(id);
thesub.objects.push(id);
thesub[thelist].push(id);
}
}
};
/**
* Delete an id from a subscene
* @param { number } id - the id to add
* @param { number } subscene - the id of the subscene
*/
rglwidgetClass.prototype.delFromSubscene = function(id, subscene) {
var thelist,
thesub = this.getObj(subscene),
obj = this.getObj(id),
ids = [id], i;
if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined")
ids = ids.concat(obj.newIds);
thesub.objects = [].concat(thesub.objects); // It might be a scalar
for (j=0; j<ids.length;j++) {
id = ids[j];
i = thesub.objects.indexOf(id);
if (i > -1) {
thesub.objects.splice(i, 1);
thelist = this.whichList(id);
i = thesub[thelist].indexOf(id);
thesub[thelist].splice(i, 1);
}
}
};
/**
* Set the ids in a subscene
* @param { number[] } ids - the ids to set
* @param { number } subsceneid - the id of the subscene
*/
rglwidgetClass.prototype.setSubsceneEntries = function(ids, subsceneid) {
var sub = this.getObj(subsceneid);
sub.objects = ids;
this.initSubscene(subsceneid);
};
/**
* Get the ids in a subscene
* @returns {number[]}
* @param { number } subscene - the id of the subscene
*/
rglwidgetClass.prototype.getSubsceneEntries = function(subscene) {
return this.getObj(subscene).objects;
};
/**
* Get the ids of the subscenes within a subscene
* @returns { number[] }
* @param { number } subscene - the id of the subscene
*/
rglwidgetClass.prototype.getChildSubscenes = function(subscene) {
return this.getObj(subscene).subscenes;
};
/**
* Start drawing
* @returns { boolean } Previous state
*/
rglwidgetClass.prototype.startDrawing = function() {
var value = this.drawing;
this.drawing = true;
return value;
};
/**
* Stop drawing and check for context loss
* @param { boolean } saved - Previous state
*/
rglwidgetClass.prototype.stopDrawing = function(saved) {
this.drawing = saved;
if (!saved && this.gl && this.gl.isContextLost())
this.restartCanvas();
};
/**
* Generate the vertex shader for an object
* @returns {string}
* @param { number } id - Id of object
*/
rglwidgetClass.prototype.getVertexShader = function(id) {
var obj = this.getObj(id),
userShader = obj.userVertexShader,
flags = obj.flags,
type = obj.type,
is_lit = flags & this.f_is_lit,
has_texture = flags & this.f_has_texture,
fixed_quads = flags & this.f_fixed_quads,
sprites_3d = flags & this.f_sprites_3d,
sprite_3d = flags & this.f_sprite_3d,
nclipplanes = this.countClipplanes(),
fixed_size = flags & this.f_fixed_size,
is_points = flags & this.f_is_points,
is_twosided = flags & this.f_is_twosided,
fat_lines = flags & this.f_fat_lines,
is_brush = flags & this.f_is_brush,
result;
if (type === "clipplanes" || sprites_3d) return;
if (typeof userShader !== "undefined") return userShader;
result = "  /* ****** "+type+" object "+id+" vertex shader ****** */\n"+
"  attribute vec3 aPos;\n"+
"  attribute vec4 aCol;\n"+
" uniform mat4 mvMatrix;\n"+
" uniform mat4 prMatrix;\n"+
" varying vec4 vCol;\n"+
" varying vec4 vPosition;\n";
if ((is_lit && !fixed_quads && !is_brush) || sprite_3d)
result = result + "  attribute vec3 aNorm;\n"+
" uniform mat4 normMatrix;\n"+
" varying vec3 vNormal;\n";
if (has_texture || type === "text")
result = result + " attribute vec2 aTexcoord;\n"+
" varying vec2 vTexcoord;\n";
if (fixed_size)
result = result + "  uniform vec2 textScale;\n";
if (fixed_quads)
result = result + "  attribute vec2 aOfs;\n";
else if (sprite_3d)
result = result + "  uniform vec3 uOrig;\n"+
"  uniform float uSize;\n"+
"  uniform mat4 usermat;\n";
if (is_twosided)
result = result + "  attribute vec3 aPos1;\n"+
"  attribute vec3 aPos2;\n"+
"  varying float normz;\n";
if (fat_lines) {
result = result +   "  attribute vec3 aNext;\n"+
"  attribute vec2 aPoint;\n"+
"  varying vec2 vPoint;\n"+
"  varying float vLength;\n"+
"  uniform float uAspect;\n"+
"  uniform float uLwd;\n";
}
result = result + "  void main(void) {\n";
if ((nclipplanes || (!fixed_quads && !sprite_3d)) && !is_brush)
result = result + "    vPosition = mvMatrix * vec4(aPos, 1.);\n";
if (!fixed_quads && !sprite_3d && !is_brush)
result = result + "    gl_Position = prMatrix * vPosition;\n";
if (is_points) {
var size = this.getMaterial(id, "size");
result = result + "    gl_PointSize = "+size.toFixed(1)+";\n";
}
result = result + "    vCol = aCol;\n";
if (is_lit && !fixed_quads && !sprite_3d && !is_brush)
result = result + "    vNormal = normalize((normMatrix * vec4(aNorm, 1.)).xyz);\n";
if (has_texture || type == "text")
result = result + "    vTexcoord = aTexcoord;\n";
if (fixed_size)
result = result + "    vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n"+
"   pos = pos/pos.w;\n"+
"   gl_Position = pos + vec4(aOfs*textScale, 0.,0.);\n";
if (type == "sprites" && !fixed_size)
result = result + "    vec4 pos = mvMatrix * vec4(aPos, 1.);\n"+
"   pos = pos/pos.w + vec4(aOfs, 0., 0.);\n"+
"   gl_Position = prMatrix*pos;\n";
if (sprite_3d)
result = result + "   vNormal = normalize((normMatrix * vec4(aNorm, 1.)).xyz);\n"+
"   vec4 pos = mvMatrix * vec4(uOrig, 1.);\n"+
"   vPosition = pos/pos.w + vec4(uSize*(vec4(aPos, 1.)*usermat).xyz,0.);\n"+
"   gl_Position = prMatrix * vPosition;\n";
if (is_twosided)
result = result + "   vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n"+
"   pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n"+
"   vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n"+
"   pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n"+
"   normz = pos1.x*pos2.y - pos1.y*pos2.x;\n";
if (fat_lines) 
/* This code was inspired by Matt Deslauriers' code in https://mattdesl.svbtle.com/drawing-lines-is-hard */
result = result + "   vec2 aspectVec = vec2(uAspect, 1.0);\n"+
"   mat4 projViewModel = prMatrix * mvMatrix;\n"+
"   vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n"+
"   currentProjected = currentProjected/currentProjected.w;\n"+
"   vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n"+
"   vec2 currentScreen = currentProjected.xy * aspectVec;\n"+
"   vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n"+
"   float len = uLwd;\n"+
"   vec2 dir = vec2(1.0, 0.0);\n"+
"   vPoint = aPoint;\n"+
"   vLength = length(nextScreen - currentScreen)/2.0;\n"+
"   vLength = vLength/(vLength + len);\n"+
"   if (vLength > 0.0) {\n"+
"     dir = normalize(nextScreen - currentScreen);\n"+
"   }\n"+
"   vec2 normal = vec2(-dir.y, dir.x);\n"+
"   dir.x /= uAspect;\n"+
"   normal.x /= uAspect;\n"+
"   vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n"+
"   gl_Position = currentProjected + offset;\n";
if (is_brush)
result = result + "   gl_Position = vec4(aPos, 1.);\n";
result = result + "  }\n";
// console.log(result);
return result;
};
/**
* Generate the fragment shader for an object
* @returns {string}
* @param { number } id - Id of object
*/
rglwidgetClass.prototype.getFragmentShader = function(id) {
var obj = this.getObj(id),
userShader = obj.userFragmentShader,
flags = obj.flags,
type = obj.type,
is_lit = flags & this.f_is_lit,
has_texture = flags & this.f_has_texture,
fixed_quads = flags & this.f_fixed_quads,
sprites_3d = flags & this.f_sprites_3d,
is_twosided = (flags & this.f_is_twosided) > 0,
fat_lines = flags & this.f_fat_lines,
is_transparent = flags & this.f_is_transparent,
nclipplanes = this.countClipplanes(), i,
texture_format, nlights,
result;
if (type === "clipplanes" || sprites_3d) return;
if (typeof userShader !== "undefined") return userShader;
if (has_texture)
texture_format = this.getMaterial(id, "textype");
result = "/* ****** "+type+" object "+id+" fragment shader ****** */\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"  precision highp float;\n"+
"#else\n"+
"  precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"  varying vec4 vCol; // carries alpha\n"+
"  varying vec4 vPosition;\n";
if (has_texture || type === "text")
result = result + "  varying vec2 vTexcoord;\n"+
" uniform sampler2D uSampler;\n";
if (is_lit && !fixed_quads)
result = result + "  varying vec3 vNormal;\n";
for (i = 0; i < nclipplanes; i++)
result = result + "  uniform vec4 vClipplane"+i+";\n";
if (is_lit) {
nlights = this.countLights();
if (nlights)
result = result + "  uniform mat4 mvMatrix;\n";
else
is_lit = false;
}
if (is_lit) {
result = result + "   uniform vec3 emission;\n"+
"   uniform float shininess;\n";
for (i=0; i < nlights; i++) {
result = result + "   uniform vec3 ambient" + i + ";\n"+
"   uniform vec3 specular" + i +"; // light*material\n"+
"   uniform vec3 diffuse" + i + ";\n"+
"   uniform vec3 lightDir" + i + ";\n"+
"   uniform bool viewpoint" + i + ";\n"+
"   uniform bool finite" + i + ";\n";
}
}
if (is_twosided)
result = result + "   uniform bool front;\n"+
"   varying float normz;\n";
if (fat_lines)
result = result + "   varying vec2 vPoint;\n"+
"   varying float vLength;\n";
result = result + "  void main(void) {\n";
if (fat_lines) {
result = result + "    vec2 point = vPoint;\n"+
"    bool neg = point.y < 0.0;\n"+
"    point.y = neg ? "+
"      (point.y + vLength)/(1.0 - vLength) :\n"+
"     -(point.y - vLength)/(1.0 - vLength);\n";
if (is_transparent && type == "linestrip")
result = result+"    if (neg && length(point) <= 1.0) discard;\n";
result = result + "    point.y = min(point.y, 0.0);\n"+
"    if (length(point) > 1.0) discard;\n";
}
for (i=0; i < nclipplanes;i++)
result = result + "    if (dot(vPosition, vClipplane"+i+") < 0.0) discard;\n";
if (fixed_quads) {
result = result +   "    vec3 n = vec3(0., 0., 1.);\n";
} else if (is_lit) {
result = result +   "    vec3 n = normalize(vNormal);\n";
}
if (is_twosided) {
result = result +   "    if ((normz <= 0.) != front) discard;\n";
}
if (is_lit) {
result = result + "    vec3 eye = normalize(-vPosition.xyz);\n"+
"   vec3 lightdir;\n"+
"   vec4 colDiff;\n"+
"   vec3 halfVec;\n"+
"   vec4 lighteffect = vec4(emission, 0.);\n"+
"   vec3 col;\n"+
"   float nDotL;\n";
if (!fixed_quads) {
result = result +   "   n = -faceforward(n, n, eye);\n";
}
for (i=0; i < nlights; i++) {
result = result + "   colDiff = vec4(vCol.rgb * diffuse" + i + ", vCol.a);\n"+
"   lightdir = lightDir" + i + ";\n"+
"   if (!viewpoint" + i +")\n"+
"     lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n"+
"   if (!finite" + i + ") {\n"+
"     halfVec = normalize(lightdir + eye);\n"+
"   } else {\n"+
"     lightdir = normalize(lightdir - vPosition.xyz);\n"+
"     halfVec = normalize(lightdir + eye);\n"+
"   }\n"+
"    col = ambient" + i + ";\n"+
"   nDotL = dot(n, lightdir);\n"+
"   col = col + max(nDotL, 0.) * colDiff.rgb;\n"+
"   col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular" + i + ";\n"+
"   lighteffect = lighteffect + vec4(col, colDiff.a);\n";
}
} else {
result = result +   "   vec4 colDiff = vCol;\n"+
"    vec4 lighteffect = colDiff;\n";
}
if (type === "text")
result = result +   "    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n";
if (has_texture) {
result = result + {
rgb:            "   vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);\n",
rgba:           "   vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n",
alpha:          "   vec4 textureColor = texture2D(uSampler, vTexcoord);\n"+
"   float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;\n"+
"   textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);\n",
luminance:      "   vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);\n",
"luminance.alpha":"    vec4 textureColor = texture2D(uSampler, vTexcoord);\n"+
"   float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"   textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);\n"
}[texture_format]+
"   gl_FragColor = textureColor;\n";
} else if (type === "text") {
result = result +   "    if (textureColor.a < 0.1)\n"+
"     discard;\n"+
"   else\n"+
"     gl_FragColor = textureColor;\n";
} else
result = result +   "   gl_FragColor = lighteffect;\n";
//if (fat_lines)
//  result = result +   "   gl_FragColor = vec4(0.0, abs(point.x), abs(point.y), 1.0);"
result = result + "  }\n";
// console.log(result);
return result;
};
/**
* Call gl functions to create and compile shader
* @returns {Object}
* @param { number } shaderType - gl code for shader type
* @param { string } code - code for the shader
*/
rglwidgetClass.prototype.getShader = function(shaderType, code) {
var gl = this.gl, shader;
shader = gl.createShader(shaderType);
gl.shaderSource(shader, code);
gl.compileShader(shader);
if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost())
alert(gl.getShaderInfoLog(shader));
return shader;
};
/**
* Handle a texture after its image has been loaded
* @param { Object } texture - the gl texture object
* @param { Object } textureCanvas - the canvas holding the image
*/
rglwidgetClass.prototype.handleLoadedTexture = function(texture, textureCanvas) {
var gl = this.gl || this.initGL();
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureCanvas);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
gl.generateMipmap(gl.TEXTURE_2D);
gl.bindTexture(gl.TEXTURE_2D, null);
};
/**
* Get maximum dimension of texture in current browser.
* @returns {number}
*/
rglwidgetClass.prototype.getMaxTexSize = function() {
var gl = this.gl || this.initGL();  
return Math.min(4096, gl.getParameter(gl.MAX_TEXTURE_SIZE));
};
/**
* Load an image to a texture
* @param { string } uri - The image location
* @param { Object } texture - the gl texture object
*/
rglwidgetClass.prototype.loadImageToTexture = function(uri, texture) {
var canvas = this.textureCanvas,
ctx = canvas.getContext("2d"),
image = new Image(),
self = this;
image.onload = function() {
var w = image.width,
h = image.height,
canvasX = self.getPowerOfTwo(w),
canvasY = self.getPowerOfTwo(h),
gl = self.gl || self.initGL(),
maxTexSize = self.getMaxTexSize();
while (canvasX > 1 && canvasY > 1 && (canvasX > maxTexSize || canvasY > maxTexSize)) {
canvasX /= 2;
canvasY /= 2;
}
canvas.width = canvasX;
canvas.height = canvasY;
ctx.imageSmoothingEnabled = true;
ctx.drawImage(image, 0, 0, canvasX, canvasY);
self.handleLoadedTexture(texture, canvas);
self.drawScene();
};
image.src = uri;
};
/**
* Draw text to the texture canvas
* @returns { Object } object with text measurements
* @param { string } text - the text
* @param { number } cex - expansion
* @param { string } family - font family
* @param { number } font - font number
*/
rglwidgetClass.prototype.drawTextToCanvas = function(text, cex, family, font) {
var canvasX, canvasY,
textY,
scaling = 20,
textColour = "white",
backgroundColour = "rgba(0,0,0,0)",
canvas = this.textureCanvas,
ctx = canvas.getContext("2d"),
i, textHeight = 0, textHeights = [], width, widths = [], 
offsetx, offsety = 0, line, lines = [], offsetsx = [],
offsetsy = [], lineoffsetsy = [], fontStrings = [],
maxTexSize = this.getMaxTexSize(),
getFontString = function(i) {
textHeights[i] = scaling*cex[i];
var fontString = textHeights[i] + "px",
family0 = family[i],
font0 = font[i];
if (family0 === "sans")
family0 = "sans-serif";
else if (family0 === "mono")
family0 = "monospace";
fontString = fontString + " " + family0;
if (font0 === 2 || font0 === 4)
fontString = "bold " + fontString;
if (font0 === 3 || font0 === 4)
fontString = "italic " + fontString;
return fontString;
};
cex = this.repeatToLen(cex, text.length);
family = this.repeatToLen(family, text.length);
font = this.repeatToLen(font, text.length);
canvasX = 1;
line = -1;
offsetx = maxTexSize;
for (i = 0; i < text.length; i++)  {
ctx.font = fontStrings[i] = getFontString(i);
width = widths[i] = ctx.measureText(text[i]).width;
if (offsetx + width > maxTexSize) {
line += 1;
offsety = lineoffsetsy[line] = offsety + 2*textHeight;
if (offsety > maxTexSize)
console.error("Too many strings for texture.");
textHeight = 0;
offsetx = 0;
}
textHeight = Math.max(textHeight, textHeights[i]);
offsetsx[i] = offsetx;
offsetx += width;
canvasX = Math.max(canvasX, offsetx);
lines[i] = line;
}
offsety = lineoffsetsy[line] = offsety + 2*textHeight;
for (i = 0; i < text.length; i++) {
offsetsy[i] = lineoffsetsy[lines[i]];
}
canvasX = this.getPowerOfTwo(canvasX);
canvasY = this.getPowerOfTwo(offsety);
canvas.width = canvasX;
canvas.height = canvasY;
ctx.fillStyle = backgroundColour;
ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
ctx.textBaseline = "alphabetic";
for(i = 0; i < text.length; i++) {
ctx.font = fontStrings[i];
ctx.fillStyle = textColour;
ctx.textAlign = "left";
ctx.fillText(text[i], offsetsx[i],  offsetsy[i]);
}
return {canvasX:canvasX, canvasY:canvasY,
widths:widths, textHeights:textHeights,
offsetsx:offsetsx, offsetsy:offsetsy};
};
/**
* Set the gl viewport and scissor test
* @param { number } id - id of subscene
*/
rglwidgetClass.prototype.setViewport = function(id) {
var gl = this.gl || this.initGL(),
vp = this.getObj(id).par3d.viewport,
x = vp.x*this.canvas.width,
y = vp.y*this.canvas.height,
width = vp.width*this.canvas.width,
height = vp.height*this.canvas.height;
this.vp = {x:x, y:y, width:width, height:height};
gl.viewport(x, y, width, height);
gl.scissor(x, y, width, height);
gl.enable(gl.SCISSOR_TEST);
};
/**
* Set the projection matrix for a subscene
* @param { number } id - id of subscene
*/
rglwidgetClass.prototype.setprMatrix = function(id) {
var subscene = this.getObj(id),
embedding = subscene.embeddings.projection;
if (embedding === "replace")
this.prMatrix.makeIdentity();
else
this.setprMatrix(subscene.parent);
if (embedding === "inherit")
return;
// This is based on the Frustum::enclose code from geom.cpp
var bbox = subscene.par3d.bbox,
scale = subscene.par3d.scale,
ranges = [(bbox[1]-bbox[0])*scale[0]/2,
(bbox[3]-bbox[2])*scale[1]/2,
(bbox[5]-bbox[4])*scale[2]/2],
radius = Math.sqrt(this.sumsq(ranges))*1.1; // A bit bigger to handle labels
if (radius <= 0) radius = 1;
var observer = subscene.par3d.observer,
distance = observer[2],
FOV = subscene.par3d.FOV, ortho = FOV === 0,
t = ortho ? 1 : Math.tan(FOV*Math.PI/360),
near = distance - radius,
far = distance + radius,
hlen,
aspect = this.vp.width/this.vp.height,
z = subscene.par3d.zoom,
userProjection = subscene.par3d.userProjection;
if (far < 0.0)
far = 1.0;
if (near < far/100.0)
near = far/100.0;
hlen = t*near;
if (ortho) {
if (aspect > 1)
this.prMatrix.ortho(-hlen*aspect*z, hlen*aspect*z,
-hlen*z, hlen*z, near, far);
else
this.prMatrix.ortho(-hlen*z, hlen*z,
-hlen*z/aspect, hlen*z/aspect,
near, far);
} else {
if (aspect > 1)
this.prMatrix.frustum(-hlen*aspect*z, hlen*aspect*z,
-hlen*z, hlen*z, near, far);
else
this.prMatrix.frustum(-hlen*z, hlen*z,
-hlen*z/aspect, hlen*z/aspect,
near, far);
}
this.prMatrix.multRight(userProjection);
};
/**
* Set the model-view matrix for a subscene
* @param { number } id - id of the subscene
*/
rglwidgetClass.prototype.setmvMatrix = function(id) {
var observer = this.getObj(id).par3d.observer;
this.mvMatrix.makeIdentity();
this.setmodelMatrix(id);
this.mvMatrix.translate(-observer[0], -observer[1], -observer[2]);
};
/**
* Set the model matrix for a subscene
* @param { number } id - id of the subscene
*/
rglwidgetClass.prototype.setmodelMatrix = function(id) {
var subscene = this.getObj(id),
embedding = subscene.embeddings.model;
if (embedding !== "inherit") {
var scale = subscene.par3d.scale,
bbox = subscene.par3d.bbox,
center = [(bbox[0]+bbox[1])/2,
(bbox[2]+bbox[3])/2,
(bbox[4]+bbox[5])/2];
this.mvMatrix.translate(-center[0], -center[1], -center[2]);
this.mvMatrix.scale(scale[0], scale[1], scale[2]);
this.mvMatrix.multRight( subscene.par3d.userMatrix );
}
if (embedding !== "replace")
this.setmodelMatrix(subscene.parent);
};
/**
* Set the normals matrix for a subscene
* @param { number } subsceneid - id of the subscene
*/
rglwidgetClass.prototype.setnormMatrix = function(subsceneid) {
var self = this,
recurse = function(id) {
var sub = self.getObj(id),
embedding = sub.embeddings.model;
if (embedding !== "inherit") {
var scale = sub.par3d.scale;
self.normMatrix.scale(1/scale[0], 1/scale[1], 1/scale[2]);
self.normMatrix.multRight(sub.par3d.userMatrix);
}
if (embedding !== "replace")
recurse(sub.parent);
};
self.normMatrix.makeIdentity();
recurse(subsceneid);
};
/**
* Set the combined projection-model-view matrix
*/
rglwidgetClass.prototype.setprmvMatrix = function() {
this.prmvMatrix = new CanvasMatrix4( this.mvMatrix );
this.prmvMatrix.multRight( this.prMatrix );
};
/**
* Count clipping planes in a scene
* @returns {number}
*/
rglwidgetClass.prototype.countClipplanes = function() {
return this.countObjs("clipplanes");
};
/**
* Count lights in a scene
* @returns { number }
*/
rglwidgetClass.prototype.countLights = function() {
return this.countObjs("light");
};
/**
* Count objects of specific type in a scene
* @returns { number }
* @param { string } type - Type of object to count
*/
rglwidgetClass.prototype.countObjs = function(type) {
var self = this,
bound = 0;
Object.keys(this.scene.objects).forEach(
function(key) {
if (self.getObj(parseInt(key, 10)).type === type)
bound = bound + 1;
});
return bound;
};
/**
* Initialize a subscene
* @param { number } id - id of subscene.
*/
rglwidgetClass.prototype.initSubscene = function(id) {
var sub = this.getObj(id),
i, obj;
if (sub.type !== "subscene")
return;
sub.par3d.userMatrix = this.toCanvasMatrix4(sub.par3d.userMatrix);
sub.par3d.userProjection = this.toCanvasMatrix4(sub.par3d.userProjection);
sub.par3d.userProjection.transpose();
sub.par3d.listeners = [].concat(sub.par3d.listeners);
sub.backgroundId = undefined;
sub.subscenes = [];
sub.clipplanes = [];
sub.transparent = [];
sub.opaque = [];
sub.lights = [];
for (i=0; i < sub.objects.length; i++) {
obj = this.getObj(sub.objects[i]);
if (typeof obj === "undefined") {
sub.objects.splice(i, 1);
i--;
} else if (obj.type === "background")
sub.backgroundId = obj.id;
else
sub[this.whichList(obj.id)].push(obj.id);
}
};
/**
* Copy object
* @param { number } id - id of object to copy
* @param { string } reuse - Document id of scene to reuse
*/
rglwidgetClass.prototype.copyObj = function(id, reuse) {
var obj = this.getObj(id),
prev = document.getElementById(reuse);
if (prev !== null) {
prev = prev.rglinstance;
var
prevobj = prev.getObj(id),
fields = ["flags", "type",
"colors", "vertices", "centers",
"normals", "offsets",
"texts", "cex", "family", "font", "adj",
"material",
"radii",
"texcoords",
"userMatrix", "ids",
"dim",
"par3d", "userMatrix",
"viewpoint", "finite",
"pos"],
i;
for (i = 0; i < fields.length; i++) {
if (typeof prevobj[fields[i]] !== "undefined")
obj[fields[i]] = prevobj[fields[i]];
}
} else
console.warn("copyObj failed");
};
/**
* Update the triangles used to display a plane
* @param { number } id - id of the plane
* @param { Object } bbox - bounding box in which to display the plane
*/
rglwidgetClass.prototype.planeUpdateTriangles = function(id, bbox) {
var perms = [[0,0,1], [1,2,2], [2,1,0]],
x, xrow, elem, A, d, nhits, i, j, k, u, v, w, intersect, which, v0, v2, vx, reverse,
face1 = [], face2 = [], normals = [],
obj = this.getObj(id),
nPlanes = obj.normals.length;
obj.bbox = bbox;
obj.vertices = [];
obj.initialized = false;
for (elem = 0; elem < nPlanes; elem++) {
//    Vertex Av = normal.getRecycled(elem);
x = [];
A = obj.normals[elem];
d = obj.offsets[elem][0];
nhits = 0;
for (i=0; i<3; i++)
for (j=0; j<2; j++)
for (k=0; k<2; k++) {
u = perms[0][i];
v = perms[1][i];
w = perms[2][i];
if (A[w] !== 0.0) {
intersect = -(d + A[u]*bbox[j+2*u] + A[v]*bbox[k+2*v])/A[w];
if (bbox[2*w] < intersect && intersect < bbox[1+2*w]) {
xrow = [];
xrow[u] = bbox[j+2*u];
xrow[v] = bbox[k+2*v];
xrow[w] = intersect;
x.push(xrow);
face1[nhits] = j + 2*u;
face2[nhits] = k + 2*v;
nhits++;
}
}
}
if (nhits > 3) {
/* Re-order the intersections so the triangles work */
for (i=0; i<nhits-2; i++) {
which = 0; /* initialize to suppress warning */
for (j=i+1; j<nhits; j++) {
if (face1[i] == face1[j] || face1[i] == face2[j] ||
face2[i] == face1[j] || face2[i] == face2[j] ) {
which = j;
break;
}
}
if (which > i+1) {
this.swap(x, i+1, which);
this.swap(face1, i+1, which);
this.swap(face2, i+1, which);
}
}
}
if (nhits >= 3) {
/* Put in order so that the normal points out the FRONT of the faces */
v0 = [x[0][0] - x[1][0] , x[0][1] - x[1][1], x[0][2] - x[1][2]];
v2 = [x[2][0] - x[1][0] , x[2][1] - x[1][1], x[2][2] - x[1][2]];
/* cross-product */
vx = this.xprod(v0, v2);
reverse = this.dotprod(vx, A) > 0;
for (i=0; i<nhits-2; i++) {
obj.vertices.push(x[0]);
normals.push(A);
for (j=1; j<3; j++) {
obj.vertices.push(x[i + (reverse ? 3-j : j)]);
normals.push(A);
}
}
}
}
obj.pnormals = normals;
};
rglwidgetClass.prototype.getAdj = function (pos, offset, text) {
switch(pos) {
case 1: return [0.5, 1 + offset];
case 2: return [1 + offset/text.length, 0.5];
case 3: return [0.5, -offset];
case 4: return [-offset/text.length, 0.5];
}
}
/**
* Initialize object for display
* @param { number } id - id of object to initialize
*/
rglwidgetClass.prototype.initObj = function(id) {
var obj = this.getObj(id),
flags = obj.flags,
type = obj.type,
is_lit = flags & this.f_is_lit,
is_lines = flags & this.f_is_lines,
fat_lines = flags & this.f_fat_lines,
has_texture = flags & this.f_has_texture,
fixed_quads = flags & this.f_fixed_quads,
is_transparent = obj.is_transparent,
depth_sort = flags & this.f_depth_sort,
sprites_3d = flags & this.f_sprites_3d,
sprite_3d = flags & this.f_sprite_3d,
fixed_size = flags & this.f_fixed_size,
is_twosided = (flags & this.f_is_twosided) > 0,
is_brush = flags & this.f_is_brush,
gl = this.gl || this.initGL(),
polygon_offset,
texinfo, drawtype, nclipplanes, f, nrows, oldrows,
i,j,v,v1,v2, mat, uri, matobj, pass, passes, pmode,
dim, nx, nz, attr;
if (typeof id !== "number") {
this.alertOnce("initObj id is "+typeof id);
}
obj.initialized = true;
if (type === "bboxdeco" || type === "subscene")
return;
if (type === "light") {
obj.ambient = new Float32Array(obj.colors[0].slice(0,3));
obj.diffuse = new Float32Array(obj.colors[1].slice(0,3));
obj.specular = new Float32Array(obj.colors[2].slice(0,3));
obj.lightDir = new Float32Array(obj.vertices[0]);
return;
}
if (type === "clipplanes") {
obj.vClipplane = this.flatten(this.cbind(obj.normals, obj.offsets));
return;
}
if (type === "background" && typeof obj.ids !== "undefined") {
obj.quad = this.flatten([].concat(obj.ids));
return;
}
polygon_offset = this.getMaterial(id, "polygon_offset");
if (polygon_offset[0] != 0 || polygon_offset[1] != 0)
obj.polygon_offset = polygon_offset;
if (is_transparent) {
depth_sort = ["triangles", "quads", "surface",
"spheres", "sprites", "text"].indexOf(type) >= 0;
}
if (is_brush)
this.initSelection(id);
if (typeof obj.vertices === "undefined")
obj.vertices = [];
v = obj.vertices;
obj.vertexCount = v.length;
if (!obj.vertexCount) return;
if (is_twosided) {
if (typeof obj.userAttributes === "undefined")
obj.userAttributes = {};
v1 = Array(v.length);
v2 = Array(v.length);
if (obj.type == "triangles" || obj.type == "quads") {
if (obj.type == "triangles")
nrow = 3;
else
nrow = 4;
for (i=0; i<Math.floor(v.length/nrow); i++)
for (j=0; j<nrow; j++) {
v1[nrow*i + j] = v[nrow*i + ((j+1) % nrow)];
v2[nrow*i + j] = v[nrow*i + ((j+2) % nrow)];
}
} else if (obj.type == "surface") {
dim = obj.dim[0];
nx = dim[0];
nz = dim[1];
for (j=0; j<nx; j++) {
for (i=0; i<nz; i++) {
if (i+1 < nz && j+1 < nx) {
v2[j + nx*i] = v[j + nx*(i+1)];
v1[j + nx*i] = v[j+1 + nx*(i+1)];
} else if (i+1 < nz) {
v2[j + nx*i] = v[j-1 + nx*i];
v1[j + nx*i] = v[j + nx*(i+1)];
} else {
v2[j + nx*i] = v[j + nx*(i-1)];
v1[j + nx*i] = v[j-1 + nx*(i-1)];
}
}
}
}
obj.userAttributes.aPos1 = v1;
obj.userAttributes.aPos2 = v2;
}
if (!sprites_3d) {
if (gl.isContextLost()) return;
obj.prog = gl.createProgram();
gl.attachShader(obj.prog, this.getShader( gl.VERTEX_SHADER,
this.getVertexShader(id) ));
gl.attachShader(obj.prog, this.getShader( gl.FRAGMENT_SHADER,
this.getFragmentShader(id) ));
//  Force aPos to location 0, aCol to location 1
gl.bindAttribLocation(obj.prog, 0, "aPos");
gl.bindAttribLocation(obj.prog, 1, "aCol");
gl.linkProgram(obj.prog);
var linked = gl.getProgramParameter(obj.prog, gl.LINK_STATUS);
if (!linked) {
// An error occurred while linking
var lastError = gl.getProgramInfoLog(obj.prog);
console.warn("Error in program linking:" + lastError);
gl.deleteProgram(obj.prog);
return;
}
}
if (type === "text") {
texinfo = this.drawTextToCanvas(obj.texts,
this.flatten(obj.cex),
this.flatten(obj.family),
this.flatten(obj.family));
}
if (fixed_quads && !sprites_3d) {
obj.ofsLoc = gl.getAttribLocation(obj.prog, "aOfs");
}
if (sprite_3d) {
obj.origLoc = gl.getUniformLocation(obj.prog, "uOrig");
obj.sizeLoc = gl.getUniformLocation(obj.prog, "uSize");
obj.usermatLoc = gl.getUniformLocation(obj.prog, "usermat");
}
if (has_texture || type == "text") {
if (!obj.texture)
obj.texture = gl.createTexture();
obj.texLoc = gl.getAttribLocation(obj.prog, "aTexcoord");
obj.sampler = gl.getUniformLocation(obj.prog, "uSampler");
}
if (has_texture) {
mat = obj.material;
if (typeof mat.uri !== "undefined")
uri = mat.uri;
else if (typeof mat.uriElementId === "undefined") {
matobj = this.getObj(mat.uriId);
if (typeof matobj !== "undefined") {
uri = matobj.material.uri;
} else {
uri = "";
}
} else
uri = document.getElementById(mat.uriElementId).rglinstance.getObj(mat.uriId).material.uri;
this.loadImageToTexture(uri, obj.texture);
}
if (type === "text") {
this.handleLoadedTexture(obj.texture, this.textureCanvas);
}
var stride = 3, nc, cofs, nofs, radofs, oofs, tofs, vnew, fnew,
nextofs = -1, pointofs = -1, alias, colors, key, selection, filter, adj, pos, offset;
obj.alias = undefined;
colors = obj.colors;
j = this.scene.crosstalk.id.indexOf(id);
if (j >= 0) {
key = this.scene.crosstalk.key[j];
options = this.scene.crosstalk.options[j];
colors = colors.slice(0); 
for (i = 0; i < v.length; i++)
colors[i] = obj.colors[i % obj.colors.length].slice(0);
if ( (selection = this.scene.crosstalk.selection) &&
(selection.length || !options.selectedIgnoreNone) )
for (i = 0; i < v.length; i++) {
if (!selection.includes(key[i])) {
if (options.deselectedColor)
colors[i] = options.deselectedColor.slice(0);
colors[i][3] = colors[i][3]*options.deselectedFade;   /* default: mostly transparent if not selected */
} else if (options.selectedColor)
colors[i] = options.selectedColor.slice(0);
}
if ( (filter = this.scene.crosstalk.filter) )
for (i = 0; i < v.length; i++) 
if (!filter.includes(key[i])) {
if (options.filteredColor)
colors[i] = options.filteredColor.slice(0);
colors[i][3] = colors[i][3]*options.filteredFade;   /* default: completely hidden if filtered */
}
}  
nc = obj.colorCount = colors.length;
if (nc > 1) {
cofs = stride;
stride = stride + 4;
v = this.cbind(v, colors);
} else {
cofs = -1;
obj.onecolor = this.flatten(colors);
}
if (typeof obj.normals !== "undefined") {
nofs = stride;
stride = stride + 3;
v = this.cbind(v, typeof obj.pnormals !== "undefined" ? obj.pnormals : obj.normals);
} else
nofs = -1;
if (typeof obj.radii !== "undefined") {
radofs = stride;
stride = stride + 1;
// FIXME:  always concat the radii?
if (obj.radii.length === v.length) {
v = this.cbind(v, obj.radii);
} else if (obj.radii.length === 1) {
v = v.map(function(row, i, arr) { return row.concat(obj.radii[0]);});
}
} else
radofs = -1;
// Add default indices
f = Array(v.length);
for (i = 0; i < v.length; i++)
f[i] = i;
obj.f = [f,f];
if (type == "sprites" && !sprites_3d) {
tofs = stride;
stride += 2;
oofs = stride;
stride += 2;
vnew = new Array(4*v.length);
fnew = new Array(4*v.length);
alias = new Array(v.length);
var rescale = fixed_size ? 72 : 1,
size = obj.radii, s = rescale*size[0]/2;
last = v.length;
f = obj.f[0];
for (i=0; i < v.length; i++) {
if (size.length > 1)
s = rescale*size[i]/2;
vnew[i]  = v[i].concat([0,0,-s,-s]);
fnew[4*i] = f[i];
vnew[last]= v[i].concat([1,0, s,-s]);
fnew[4*i+1] = last++;
vnew[last]= v[i].concat([1,1, s, s]);
fnew[4*i+2] = last++;
vnew[last]= v[i].concat([0,1,-s, s]);
fnew[4*i+3] = last++;
alias[i] = [last-3, last-2, last-1];
}
v = vnew;
obj.vertexCount = v.length;
obj.f = [fnew, fnew];
} else if (type === "text") {
tofs = stride;
stride += 2;
oofs = stride;
stride += 2;
vnew = new Array(4*v.length);
f = obj.f[0];
fnew = new Array(4*f.length);
alias = new Array(v.length);
last = v.length;
adj = this.flatten(obj.adj);
if (typeof obj.pos !== "undefined") {
pos = this.flatten(obj.pos);
offset = adj[0];
}
for (i=0; i < v.length; i++) {
if (typeof pos !== "undefined")
adj = this.getAdj(pos[i % pos.length], offset, obj.texts[i]);
vnew[i]  = v[i].concat([0,-0.5]).concat(adj);
fnew[4*i] = f[i];
vnew[last] = v[i].concat([1,-0.5]).concat(adj);
fnew[4*i+1] = last++;
vnew[last] = v[i].concat([1, 1.5]).concat(adj);
fnew[4*i+2] = last++;
vnew[last] = v[i].concat([0, 1.5]).concat(adj);
fnew[4*i+3] = last++;
alias[i] = [last-3, last-2, last-1];
for (j=0; j < 4; j++) {
v1 = vnew[fnew[4*i+j]];
v1[tofs+2] = 2*(v1[tofs]-v1[tofs+2])*texinfo.widths[i];
v1[tofs+3] = 2*(v1[tofs+1]-v1[tofs+3])*texinfo.textHeights[i];
v1[tofs] = (texinfo.offsetsx[i] + v1[tofs]*texinfo.widths[i])/texinfo.canvasX;
v1[tofs+1] = 1.0-(texinfo.offsetsy[i] -
v1[tofs+1]*texinfo.textHeights[i])/texinfo.canvasY;
vnew[fnew[4*i+j]] = v1;
}
}
v = vnew;
obj.vertexCount = v.length;
obj.f = [fnew, fnew];
} else if (typeof obj.texcoords !== "undefined") {
tofs = stride;
stride += 2;
oofs = -1;
v = this.cbind(v, obj.texcoords);
} else {
tofs = -1;
oofs = -1;
}
obj.alias = alias;
if (typeof obj.userAttributes !== "undefined") {
obj.userAttribOffsets = {};
obj.userAttribLocations = {};
obj.userAttribSizes = {};
for (attr in obj.userAttributes) {
obj.userAttribLocations[attr] = gl.getAttribLocation(obj.prog, attr);
if (obj.userAttribLocations[attr] >= 0) { // Attribute may not have been used
obj.userAttribOffsets[attr] = stride;
v = this.cbind(v, obj.userAttributes[attr]);
stride = v[0].length;
obj.userAttribSizes[attr] = stride - obj.userAttribOffsets[attr];
}
}
}
if (typeof obj.userUniforms !== "undefined") {
obj.userUniformLocations = {};
for (attr in obj.userUniforms)
obj.userUniformLocations[attr] = gl.getUniformLocation(obj.prog, attr);
}
if (sprites_3d) {
obj.userMatrix = new CanvasMatrix4(obj.userMatrix);
obj.objects = this.flatten([].concat(obj.ids));
is_lit = false;
for (i=0; i < obj.objects.length; i++)
this.initObj(obj.objects[i]);
}
if (is_lit && !fixed_quads) {
obj.normLoc = gl.getAttribLocation(obj.prog, "aNorm");
}
nclipplanes = this.countClipplanes();
if (nclipplanes && !sprites_3d) {
obj.clipLoc = [];
for (i=0; i < nclipplanes; i++)
obj.clipLoc[i] = gl.getUniformLocation(obj.prog,"vClipplane" + i);
}
if (is_lit) {
obj.emissionLoc = gl.getUniformLocation(obj.prog, "emission");
obj.emission = new Float32Array(this.stringToRgb(this.getMaterial(id, "emission")));
obj.shininessLoc = gl.getUniformLocation(obj.prog, "shininess");
obj.shininess = this.getMaterial(id, "shininess");
obj.nlights = this.countLights();
obj.ambientLoc = [];
obj.ambient = new Float32Array(this.stringToRgb(this.getMaterial(id, "ambient")));
obj.specularLoc = [];
obj.specular = new Float32Array(this.stringToRgb(this.getMaterial(id, "specular")));
obj.diffuseLoc = [];
obj.lightDirLoc = [];
obj.viewpointLoc = [];
obj.finiteLoc = [];
for (i=0; i < obj.nlights; i++) {
obj.ambientLoc[i] = gl.getUniformLocation(obj.prog, "ambient" + i);
obj.specularLoc[i] = gl.getUniformLocation(obj.prog, "specular" + i);
obj.diffuseLoc[i] = gl.getUniformLocation(obj.prog, "diffuse" + i);
obj.lightDirLoc[i] = gl.getUniformLocation(obj.prog, "lightDir" + i);
obj.viewpointLoc[i] = gl.getUniformLocation(obj.prog, "viewpoint" + i);
obj.finiteLoc[i] = gl.getUniformLocation(obj.prog, "finite" + i);
}
}
obj.passes = is_twosided + 1;
obj.pmode = new Array(obj.passes);
for (pass = 0; pass < obj.passes; pass++) {
if (type === "triangles" || type === "quads" || type === "surface")
pmode = this.getMaterial(id, (pass === 0) ? "front" : "back");
else pmode = "filled";
obj.pmode[pass] = pmode;
}
obj.f.length = obj.passes;
for (pass = 0; pass < obj.passes; pass++) {
f = fnew = obj.f[pass];
pmode = obj.pmode[pass];
if (pmode === "culled")
f = [];
else if (pmode === "points") {
// stay with default
} else if ((type === "quads" || type === "text" ||
type === "sprites") && !sprites_3d) {
nrows = Math.floor(obj.vertexCount/4);
if (pmode === "filled") {
fnew = Array(6*nrows);
for (i=0; i < nrows; i++) {
fnew[6*i] = f[4*i];
fnew[6*i+1] = f[4*i + 1];
fnew[6*i+2] = f[4*i + 2];
fnew[6*i+3] = f[4*i];
fnew[6*i+4] = f[4*i + 2];
fnew[6*i+5] = f[4*i + 3];
}
} else {
fnew = Array(8*nrows);
for (i=0; i < nrows; i++) {
fnew[8*i] = f[4*i];
fnew[8*i+1] = f[4*i + 1];
fnew[8*i+2] = f[4*i + 1];
fnew[8*i+3] = f[4*i + 2];
fnew[8*i+4] = f[4*i + 2];
fnew[8*i+5] = f[4*i + 3];
fnew[8*i+6] = f[4*i + 3];
fnew[8*i+7] = f[4*i];
}
}
} else if (type === "triangles") {
nrows = Math.floor(obj.vertexCount/3);
if (pmode === "filled") {
fnew = Array(3*nrows);
for (i=0; i < fnew.length; i++) {
fnew[i] = f[i];
}
} else if (pmode === "lines") {
fnew = Array(6*nrows);
for (i=0; i < nrows; i++) {
fnew[6*i] = f[3*i];
fnew[6*i + 1] = f[3*i + 1];
fnew[6*i + 2] = f[3*i + 1];
fnew[6*i + 3] = f[3*i + 2];
fnew[6*i + 4] = f[3*i + 2];
fnew[6*i + 5] = f[3*i];
}
}
} else if (type === "spheres") {
// default
} else if (type === "surface") {
dim = obj.dim[0];
nx = dim[0];
nz = dim[1];
if (pmode === "filled") {
fnew = [];
for (j=0; j<nx-1; j++) {
for (i=0; i<nz-1; i++) {
fnew.push(f[j + nx*i],
f[j + nx*(i+1)],
f[j + 1 + nx*(i+1)],
f[j + nx*i],
f[j + 1 + nx*(i+1)],
f[j + 1 + nx*i]);
}
}
} else if (pmode === "lines") {
fnew = [];
for (j=0; j<nx; j++) {
for (i=0; i<nz; i++) {
if (i+1 < nz)
fnew.push(f[j + nx*i],
f[j + nx*(i+1)]);
if (j+1 < nx)
fnew.push(f[j + nx*i],
f[j+1 + nx*i]);
}
}
}
}
obj.f[pass] = fnew;
if (depth_sort) {
drawtype = "DYNAMIC_DRAW";
} else {
drawtype = "STATIC_DRAW";
}
}
if (fat_lines) {
alias = undefined;
obj.nextLoc = gl.getAttribLocation(obj.prog, "aNext");
obj.pointLoc = gl.getAttribLocation(obj.prog, "aPoint");
obj.aspectLoc = gl.getUniformLocation(obj.prog, "uAspect");
obj.lwdLoc = gl.getUniformLocation(obj.prog, "uLwd");
// Expand vertices to turn each segment into a pair of triangles
for (pass = 0; pass < obj.passes; pass++) {
f = obj.f[pass];    
oldrows = f.length;
if (obj.pmode[pass] === "lines") 
break;
}
if (type === "linestrip") 
nrows = 4*(oldrows - 1); 
else
nrows = 2*oldrows;
vnew = new Array(nrows);
fnew = new Array(1.5*nrows);
var fnext = new Array(nrows),
fpt = new Array(nrows), 
pt, start, gap = type === "linestrip" ? 3 : 1;
// We're going to turn each pair of vertices into 4 new ones, with the "next" and "pt" attributes
// added.
// We do this by copying the originals in the first pass, adding the new attributes, then in a 
// second pass add new vertices at the end.
for (i = 0; i < v.length; i++) {
vnew[i] = v[i].concat([0,0,0,0,0]); 
}
nextofs = stride;
pointofs = stride + 3;
stride = stride + 5;
// Now add the extras
last = v.length - 1;
ind = 0;
alias = new Array(f.length);
for (i = 0; i < f.length; i++)
alias[i] = [];
for (i = 0; i < f.length - 1; i++) {
if (type !== "linestrip" && i % 2 == 1)
continue;
k = ++last;
vnew[k] = vnew[f[i]].slice();
for (j=0; j<3; j++)
vnew[k][nextofs + j] = vnew[f[i+1]][j];
vnew[k][pointofs] = -1;
vnew[k][pointofs+1] = -1;
fnew[ind] = k;
last++;
vnew[last] = vnew[k].slice();
vnew[last][pointofs] = 1;
fnew[ind+1] = last;
alias[f[i]].push(last-1, last);
last++;
k = last;
vnew[k] = vnew[f[i+1]].slice();
for (j=0; j<3; j++)
vnew[k][nextofs + j] = vnew[f[i]][j];
vnew[k][pointofs] = -1;
vnew[k][pointofs+1] = 1;
fnew[ind+2] = k;
fnew[ind+3] = fnew[ind+1];
last++;
vnew[last] = vnew[k].slice();
vnew[last][pointofs] = 1;
fnew[ind+4] = last;
fnew[ind+5] = fnew[ind+2];
ind += 6;
alias[f[i+1]].push(last-1, last);
}
vnew.length = last+1;
v = vnew;
obj.vertexCount = v.length;
if (typeof alias !== "undefined" && typeof obj.alias !== "undefined") {  // Already have aliases from previous section?
var oldalias = obj.alias, newalias = Array(obj.alias.length);
for (i = 0; i < newalias.length; i++) {
newalias[i] = oldalias[i].slice();
for (j = 0; j < oldalias[i].length; j++)
Array.prototype.push.apply(newalias[i], alias[oldalias[j]]); // pushes each element 
}
obj.alias = newalias;
} else
obj.alias = alias;
for (pass = 0; pass < obj.passes; pass++)
if (type === "lines" || type === "linestrip" || obj.pmode[pass] == "lines") {
obj.f[pass] = fnew;
}
if (depth_sort) 
drawtype = "DYNAMIC_DRAW";
else
drawtype = "STATIC_DRAW";
}
for (pass = 0; pass < obj.passes; pass++) {
if (obj.vertexCount > 65535) {
if (this.index_uint) {
obj.f[pass] = new Uint32Array(obj.f[pass]);
obj.index_uint = true;
} else
this.alertOnce("Object has "+obj.vertexCount+" vertices, not supported in this browser.");
} else {
obj.f[pass] = new Uint16Array(obj.f[pass]);
obj.index_uint = false;
}
}
if (stride !== v[0].length) {
this.alertOnce("problem in stride calculation");
}
obj.vOffsets = {vofs:0, cofs:cofs, nofs:nofs, radofs:radofs, oofs:oofs, tofs:tofs,
nextofs:nextofs, pointofs:pointofs, stride:stride};
obj.values = new Float32Array(this.flatten(v));
if (type !== "spheres" && !sprites_3d) {
obj.buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW); //
obj.ibuf = Array(obj.passes);
obj.ibuf[0] = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[0]);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[0], gl[drawtype]);
if (is_twosided) {
obj.ibuf[1] = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[1]);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[1], gl[drawtype]);
}
}
if (!sprites_3d) {
obj.mvMatLoc = gl.getUniformLocation(obj.prog, "mvMatrix");
obj.prMatLoc = gl.getUniformLocation(obj.prog, "prMatrix");
}
if (fixed_size) {
obj.textScaleLoc = gl.getUniformLocation(obj.prog, "textScale");
}
if (is_lit && !sprites_3d) {
obj.normMatLoc = gl.getUniformLocation(obj.prog, "normMatrix");
}
if (is_twosided) {
obj.frontLoc = gl.getUniformLocation(obj.prog, "front");
}
};
/**
* Set gl depth test based on object's material
* @param { number } id - object to use
*/
rglwidgetClass.prototype.setDepthTest = function(id) {
var gl = this.gl || this.initGL(),
tests = {never: gl.NEVER,
less:  gl.LESS,
equal: gl.EQUAL,
lequal:gl.LEQUAL,
greater: gl.GREATER,
notequal: gl.NOTEQUAL,
gequal: gl.GEQUAL,
always: gl.ALWAYS},
test = tests[this.getMaterial(id, "depth_test")];
gl.depthFunc(test);
};
rglwidgetClass.prototype.mode4type = {points : "POINTS",
linestrip : "LINE_STRIP",
abclines : "LINES",
lines : "LINES",
sprites : "TRIANGLES",
planes : "TRIANGLES",
text : "TRIANGLES",
quads : "TRIANGLES",
surface : "TRIANGLES",
triangles : "TRIANGLES"};
/**
* Sort objects from back to front
* @returns { number[] }
* @param { Object } obj - object to sort
*/
rglwidgetClass.prototype.depthSort = function(obj) {
var n = obj.centers.length,
depths = new Float32Array(n),
result = new Array(n),
compare = function(i,j) { return depths[j] - depths[i]; },
z, w;
for(i=0; i<n; i++) {
z = this.prmvMatrix.m13*obj.centers[i][0] +
this.prmvMatrix.m23*obj.centers[i][1] +
this.prmvMatrix.m33*obj.centers[i][2] +
this.prmvMatrix.m43;
w = this.prmvMatrix.m14*obj.centers[i][0] +
this.prmvMatrix.m24*obj.centers[i][1] +
this.prmvMatrix.m34*obj.centers[i][2] +
this.prmvMatrix.m44;
depths[i] = z/w;
result[i] = i;
}
result.sort(compare);
return result;
};
rglwidgetClass.prototype.disableArrays = function(obj, enabled) {
var gl = this.gl || this.initGL(),
objLocs = ["normLoc", "texLoc", "ofsLoc", "pointLoc", "nextLoc"],
thisLocs = ["posLoc", "colLoc"], i, attr;
for (i = 0; i < objLocs.length; i++) 
if (enabled[objLocs[i]]) gl.disableVertexAttribArray(obj[objLocs[i]]);
for (i = 0; i < thisLocs.length; i++)
if (enabled[thisLocs[i]]) gl.disableVertexAttribArray(this[objLocs[i]]);
if (typeof obj.userAttributes !== "undefined") {
for (attr in obj.userAttribSizes) {  // Not all attributes may have been used
gl.disableVertexAttribArray( obj.userAttribLocations[attr] );
}
}
}
/**
* Draw an object in a subscene
* @param { number } id - object to draw
* @param { number } subsceneid - id of subscene
*/
rglwidgetClass.prototype.drawObj = function(id, subsceneid) {
var obj = this.getObj(id),
subscene = this.getObj(subsceneid),
flags = obj.flags,
type = obj.type,
is_lit = flags & this.f_is_lit,
has_texture = flags & this.f_has_texture,
fixed_quads = flags & this.f_fixed_quads,
is_transparent = flags & this.f_is_transparent,
depth_sort = flags & this.f_depth_sort,
sprites_3d = flags & this.f_sprites_3d,
sprite_3d = flags & this.f_sprite_3d,
is_lines = flags & this.f_is_lines,
fat_lines = flags & this.f_fat_lines,
is_points = flags & this.f_is_points,
fixed_size = flags & this.f_fixed_size,
is_twosided = (flags & this.f_is_twosided) > 0,
gl = this.gl || this.initGL(),
mat,
sphereMV, baseofs, ofs, sscale, i, count, light,
pass, mode, pmode, attr,
enabled = {};
if (typeof id !== "number") {
this.alertOnce("drawObj id is "+typeof id);
}
if (type === "planes") {
if (obj.bbox !== subscene.par3d.bbox || !obj.initialized) {
this.planeUpdateTriangles(id, subscene.par3d.bbox);
}
}
if (!obj.initialized)
this.initObj(id);
if (type === "clipplanes") {
count = obj.offsets.length;
var IMVClip = [];
for (i=0; i < count; i++) {
IMVClip[i] = this.multMV(this.invMatrix, obj.vClipplane.slice(4*i, 4*(i+1)));
}
obj.IMVClip = IMVClip;
return;
}
if (type === "light" || type === "bboxdeco" || !obj.vertexCount)
return;
if (!is_transparent &&
obj.someHidden) {
is_transparent = true;
depth_sort = ["triangles", "quads", "surface",
"spheres", "sprites", "text"].indexOf(type) >= 0;
}        
this.setDepthTest(id);
if (sprites_3d) {
var norigs = obj.vertices.length,
savenorm = new CanvasMatrix4(this.normMatrix);
this.origs = obj.vertices;
this.usermat = new Float32Array(obj.userMatrix.getAsArray());
this.radii = obj.radii;
this.normMatrix = subscene.spriteNormmat;
for (this.iOrig=0; this.iOrig < norigs; this.iOrig++) {
for (i=0; i < obj.objects.length; i++) {
this.drawObj(obj.objects[i], subsceneid);
}
}
this.normMatrix = savenorm;
return;
} else {
gl.useProgram(obj.prog);
}
if (typeof obj.polygon_offset !== "undefined") {
gl.polygonOffset(obj.polygon_offset[0],
obj.polygon_offset[1]);
gl.enable(gl.POLYGON_OFFSET_FILL);
}
if (sprite_3d) {
gl.uniform3fv(obj.origLoc, new Float32Array(this.origs[this.iOrig]));
if (this.radii.length > 1) {
gl.uniform1f(obj.sizeLoc, this.radii[this.iOrig][0]);
} else {
gl.uniform1f(obj.sizeLoc, this.radii[0][0]);
}
gl.uniformMatrix4fv(obj.usermatLoc, false, this.usermat);
}
if (type === "spheres") {
gl.bindBuffer(gl.ARRAY_BUFFER, this.sphere.buf);
} else {
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
}
gl.uniformMatrix4fv( obj.prMatLoc, false, new Float32Array(this.prMatrix.getAsArray()) );
gl.uniformMatrix4fv( obj.mvMatLoc, false, new Float32Array(this.mvMatrix.getAsArray()) );
var clipcheck = 0,
clipplaneids = subscene.clipplanes,
clip, j;
for (i=0; i < clipplaneids.length; i++) {
clip = this.getObj(clipplaneids[i]);
for (j=0; j < clip.offsets.length; j++) {
gl.uniform4fv(obj.clipLoc[clipcheck + j], clip.IMVClip[j]);
}
clipcheck += clip.offsets.length;
}
if (typeof obj.clipLoc !== "undefined")
for (i=clipcheck; i < obj.clipLoc.length; i++)
gl.uniform4f(obj.clipLoc[i], 0,0,0,0);
if (is_lit) {
gl.uniformMatrix4fv( obj.normMatLoc, false, new Float32Array(this.normMatrix.getAsArray()) );
gl.uniform3fv( obj.emissionLoc, obj.emission);
gl.uniform1f( obj.shininessLoc, obj.shininess);
for (i=0; i < subscene.lights.length; i++) {
light = this.getObj(subscene.lights[i]);
if (!light.initialized) this.initObj(subscene.lights[i]);
gl.uniform3fv( obj.ambientLoc[i], this.componentProduct(light.ambient, obj.ambient));
gl.uniform3fv( obj.specularLoc[i], this.componentProduct(light.specular, obj.specular));
gl.uniform3fv( obj.diffuseLoc[i], light.diffuse);
gl.uniform3fv( obj.lightDirLoc[i], light.lightDir);
gl.uniform1i( obj.viewpointLoc[i], light.viewpoint);
gl.uniform1i( obj.finiteLoc[i], light.finite);
}
for (i=subscene.lights.length; i < obj.nlights; i++) {
gl.uniform3f( obj.ambientLoc[i], 0,0,0);
gl.uniform3f( obj.specularLoc[i], 0,0,0);
gl.uniform3f( obj.diffuseLoc[i], 0,0,0);
}
}
if (fixed_size) {
gl.uniform2f( obj.textScaleLoc, 0.75/this.vp.width, 0.75/this.vp.height);
}
gl.enableVertexAttribArray( this.posLoc );
enabled.posLoc = true;
var nc = obj.colorCount;
count = obj.vertexCount;
if (type === "spheres") {
subscene = this.getObj(subsceneid);
var scale = subscene.par3d.scale,
scount = count, indices;
gl.vertexAttribPointer(this.posLoc,  3, gl.FLOAT, false, 4*this.sphere.vOffsets.stride,  0);
gl.enableVertexAttribArray(obj.normLoc );
enabled.normLoc = true;
gl.vertexAttribPointer(obj.normLoc,  3, gl.FLOAT, false, 4*this.sphere.vOffsets.stride,  0);
gl.disableVertexAttribArray( this.colLoc );
var sphereNorm = new CanvasMatrix4();
sphereNorm.scale(scale[0], scale[1], scale[2]);
sphereNorm.multRight(this.normMatrix);
gl.uniformMatrix4fv( obj.normMatLoc, false, new Float32Array(sphereNorm.getAsArray()) );
if (nc == 1) {
gl.vertexAttrib4fv( this.colLoc, new Float32Array(obj.onecolor));
}
if (has_texture) {
gl.enableVertexAttribArray( obj.texLoc );
enabled.texLoc = true;
gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*this.sphere.vOffsets.stride,
4*this.sphere.vOffsets.tofs);
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, obj.texture);
gl.uniform1i( obj.sampler, 0);
}
if (depth_sort)
indices = this.depthSort(obj);
for (i = 0; i < scount; i++) {
sphereMV = new CanvasMatrix4();
if (depth_sort) {
baseofs = indices[i]*obj.vOffsets.stride;
} else {
baseofs = i*obj.vOffsets.stride;
}
ofs = baseofs + obj.vOffsets.radofs;
sscale = obj.values[ofs];
sphereMV.scale(sscale/scale[0], sscale/scale[1], sscale/scale[2]);
sphereMV.translate(obj.values[baseofs],
obj.values[baseofs+1],
obj.values[baseofs+2]);
sphereMV.multRight(this.mvMatrix);
gl.uniformMatrix4fv( obj.mvMatLoc, false, new Float32Array(sphereMV.getAsArray()) );
if (nc > 1) {
ofs = baseofs + obj.vOffsets.cofs;
gl.vertexAttrib4f( this.colLoc, obj.values[ofs],
obj.values[ofs+1],
obj.values[ofs+2],
obj.values[ofs+3] );
}
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.sphere.ibuf);
gl.drawElements(gl.TRIANGLES, this.sphere.sphereCount, gl.UNSIGNED_SHORT, 0);
}
this.disableArrays(obj, enabled);
if (typeof obj.polygon_offset !== "undefined") 
gl.disable(gl.POLYGON_OFFSET_FILL);
return;
} else {
if (obj.colorCount === 1) {
gl.disableVertexAttribArray( this.colLoc );
gl.vertexAttrib4fv( this.colLoc, new Float32Array(obj.onecolor));
} else {
gl.enableVertexAttribArray( this.colLoc );
enabled.colLoc = true;
gl.vertexAttribPointer(this.colLoc, 4, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.cofs);
}
}
if (is_lit && obj.vOffsets.nofs > 0) {
gl.enableVertexAttribArray( obj.normLoc );
enabled.normLoc = true;
gl.vertexAttribPointer(obj.normLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nofs);
}
if (has_texture || type === "text") {
gl.enableVertexAttribArray( obj.texLoc );
enabled.texLoc = true;
gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.tofs);
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, obj.texture);
gl.uniform1i( obj.sampler, 0);
}
if (fixed_quads) {
gl.enableVertexAttribArray( obj.ofsLoc );
enabled.ofsLoc = true;
gl.vertexAttribPointer(obj.ofsLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.oofs);
}
if (typeof obj.userAttributes !== "undefined") {
for (attr in obj.userAttribSizes) {  // Not all attributes may have been used
gl.enableVertexAttribArray( obj.userAttribLocations[attr] );
gl.vertexAttribPointer( obj.userAttribLocations[attr], obj.userAttribSizes[attr],
gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.userAttribOffsets[attr]);
}
}
if (typeof obj.userUniforms !== "undefined") {
for (attr in obj.userUniformLocations) {
var loc = obj.userUniformLocations[attr];
if (loc !== null) {
var uniform = obj.userUniforms[attr];
if (typeof uniform.length === "undefined")
gl.uniform1f(loc, uniform);
else if (typeof uniform[0].length === "undefined") {
uniform = new Float32Array(uniform);
switch(uniform.length) {
case 2: gl.uniform2fv(loc, uniform); break;
case 3: gl.uniform3fv(loc, uniform); break;
case 4: gl.uniform4fv(loc, uniform); break;
default: console.warn("bad uniform length");
}
} else if (uniform.length == 4 && uniform[0].length == 4)
gl.uniformMatrix4fv(loc, false, new Float32Array(uniform.getAsArray()));
else
console.warn("unsupported uniform matrix");
}
}
}
for (pass = 0; pass < obj.passes; pass++) {
pmode = obj.pmode[pass];
if (pmode === "culled")
continue;
mode = fat_lines && (is_lines || pmode == "lines") ? "TRIANGLES" : this.mode4type[type];
if (depth_sort && pmode == "filled") {// Don't try depthsorting on wireframe or points
var faces = this.depthSort(obj),
nfaces = faces.length,
frowsize = Math.floor(obj.f[pass].length/nfaces);
if (type !== "spheres") {
var f = obj.index_uint ? new Uint32Array(obj.f[pass].length) : new Uint16Array(obj.f[pass].length);
for (i=0; i<nfaces; i++) {
for (j=0; j<frowsize; j++) {
f[frowsize*i + j] = obj.f[pass][frowsize*faces[i] + j];
}
}
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[pass]);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, f, gl.DYNAMIC_DRAW);
}
}
if (is_twosided)
gl.uniform1i(obj.frontLoc, pass !== 0);
if (type !== "spheres") 
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[pass]);
if (type === "sprites" || type === "text" || type === "quads") {
count = count * 6/4;
} else if (type === "surface") {
count = obj.f[pass].length;
}
count = obj.f[pass].length;
if (!is_lines && pmode === "lines" && !fat_lines) {
mode = "LINES";
} else if (pmode === "points") {
mode = "POINTS";
}
if ((is_lines || pmode === "lines") && fat_lines) {
gl.enableVertexAttribArray(obj.pointLoc);
enabled.pointLoc = true;
gl.vertexAttribPointer(obj.pointLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.pointofs);
gl.enableVertexAttribArray(obj.nextLoc );
enabled.nextLoc = true;
gl.vertexAttribPointer(obj.nextLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nextofs);
gl.uniform1f(obj.aspectLoc, this.vp.width/this.vp.height);
gl.uniform1f(obj.lwdLoc, this.getMaterial(id, "lwd")/this.vp.height);
}
gl.vertexAttribPointer(this.posLoc,  3, gl.FLOAT, false, 4*obj.vOffsets.stride,  4*obj.vOffsets.vofs);
gl.drawElements(gl[mode], count, obj.index_uint ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT, 0);
this.disableArrays(obj, enabled);
}
if (typeof obj.polygon_offset !== "undefined") 
gl.disable(gl.POLYGON_OFFSET_FILL);
};
/**
* Draw the background for a subscene
* @param { number } id - id of background object
* @param { number } subsceneid - id of subscene
*/
rglwidgetClass.prototype.drawBackground = function(id, subsceneid) {
var gl = this.gl || this.initGL(),
obj = this.getObj(id),
bg, i;
if (!obj.initialized)
this.initObj(id);
if (obj.colors.length) {
bg = obj.colors[0];
gl.clearColor(bg[0], bg[1], bg[2], bg[3]);
gl.depthMask(true);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}
if (typeof obj.quad !== "undefined") {
this.prMatrix.makeIdentity();
this.mvMatrix.makeIdentity();
gl.disable(gl.BLEND);
gl.disable(gl.DEPTH_TEST);
gl.depthMask(false);
for (i=0; i < obj.quad.length; i++)
this.drawObj(obj.quad[i], subsceneid);
}
};
/**
* Draw a subscene
* @param { number } subsceneid - id of subscene
* @param { boolean } opaquePass - is this the opaque drawing pass?
*/
rglwidgetClass.prototype.drawSubscene = function(subsceneid, opaquePass) {
var gl = this.gl || this.initGL(),
sub = this.getObj(subsceneid),
objects = this.scene.objects,
subids = sub.objects,
subscene_has_faces = false,
subscene_needs_sorting = false,
flags, i, obj;
if (sub.par3d.skipRedraw)
return;
for (i=0; i < subids.length; i++) {
obj = objects[subids[i]];
flags = obj.flags;
if (typeof flags !== "undefined") {
subscene_has_faces |= (flags & this.f_is_lit)
& !(flags & this.f_fixed_quads);
obj.is_transparent = (flags & this.f_is_transparent) || obj.someHidden;
subscene_needs_sorting |= (flags & this.f_depth_sort) || obj.is_transparent;
}
}
this.setViewport(subsceneid);
if (typeof sub.backgroundId !== "undefined" && opaquePass)
this.drawBackground(sub.backgroundId, subsceneid);
if (subids.length) {
this.setprMatrix(subsceneid);
this.setmvMatrix(subsceneid);
if (subscene_has_faces) {
this.setnormMatrix(subsceneid);
if ((sub.flags & this.f_sprites_3d) &&
typeof sub.spriteNormmat === "undefined") {
sub.spriteNormmat = new CanvasMatrix4(this.normMatrix);
}
}
if (subscene_needs_sorting)
this.setprmvMatrix();
var clipids = sub.clipplanes;
if (typeof clipids === "undefined") {
console.warn("bad clipids");
}
if (clipids.length > 0) {
this.invMatrix = new CanvasMatrix4(this.mvMatrix);
this.invMatrix.invert();
for (i = 0; i < clipids.length; i++)
this.drawObj(clipids[i], subsceneid);
}
subids = sub.opaque.concat(sub.transparent);
if (opaquePass) {
gl.enable(gl.DEPTH_TEST);
gl.depthMask(true);
gl.disable(gl.BLEND);
for (i = 0; i < subids.length; i++) {
if (!this.getObj(subids[i]).is_transparent) 
this.drawObj(subids[i], subsceneid);
}
} else {
gl.depthMask(false);
gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA,
gl.ONE, gl.ONE);
gl.enable(gl.BLEND);
for (i = 0; i < subids.length; i++) {
if (this.getObj(subids[i]).is_transparent)
this.drawObj(subids[i], subsceneid);
}
}
subids = sub.subscenes;
for (i = 0; i < subids.length; i++) {
this.drawSubscene(subids[i], opaquePass);
}
}
};
/**
* Respond to brush change
*/
rglwidgetClass.prototype.selectionChanged = function() {
var i, j, k, id, subid = this.select.subscene, subscene,
objids, obj,
p1 = this.select.region.p1, p2 = this.select.region.p2,
filter, selection = [], handle, keys, xmin, x, xmax, ymin, y, ymax, z, v,
someHidden;
if (!subid)
return;
subscene = this.getObj(subid);
objids = subscene.objects;
filter = this.scene.crosstalk.filter;
this.setmvMatrix(subid);
this.setprMatrix(subid);
this.setprmvMatrix();
xmin = Math.min(p1.x, p2.x);
xmax = Math.max(p1.x, p2.x);
ymin = Math.min(p1.y, p2.y);
ymax = Math.max(p1.y, p2.y);
for (i = 0; i < objids.length; i++) {
id = objids[i];
j = this.scene.crosstalk.id.indexOf(id);
if (j >= 0) {
keys = this.scene.crosstalk.key[j];
obj = this.getObj(id);
someHidden = false;
for (k = 0; k < keys.length; k++) {
if (filter && filter.indexOf(keys[k]) < 0) {
someHidden = true;
continue;
}
v = [].concat(obj.vertices[k]).concat(1.0);
v = this.multVM(v, this.prmvMatrix);
x = v[0]/v[3];
y = v[1]/v[3];
z = v[2]/v[3];
if (xmin <= x && x <= xmax && ymin <= y && y <= ymax && -1.0 <= z && z <= 1.0) {
selection.push(keys[k]);
} else
someHidden = true;
}
obj.someHidden = someHidden && (filter || selection.length);
obj.initialized = false;
/* Who should we notify?  Only shared data in the current subscene, or everyone? */
if (!this.equalArrays(selection, this.scene.crosstalk.selection)) {
handle = this.scene.crosstalk.sel_handle[j];
handle.set(selection, {rglSubsceneId: this.select.subscene});
}
}
}
};
/**
* Respond to selection or filter change from crosstalk
* @param { Object } event - crosstalk event
* @param { boolean } filter - filter or selection?
*/
rglwidgetClass.prototype.selection = function(event, filter) {
var i, j, ids, obj, keys, crosstalk = this.scene.crosstalk,
selection, someHidden;
// Record the message and find out if this event makes some objects have mixed values:
crosstalk = this.scene.crosstalk;
if (filter) {
filter = crosstalk.filter = event.value;
selection = crosstalk.selection;
} else {  
selection = crosstalk.selection = event.value;
filter = crosstalk.filter;
}
ids = crosstalk.id;
for (i = 0; i < ids.length ; i++) {
obj = this.getObj(ids[i]);
obj.initialized = false;
keys = crosstalk.key[i];
someHidden = false;
for (j = 0; j < keys.length && !someHidden; j++) {
if ((filter && filter.indexOf(keys[j]) < 0) ||
(selection.length && selection.indexOf(keys[j]) < 0))
someHidden = true;
}
obj.someHidden = someHidden;
}
this.drawScene();
};
/**
* Clear the selection brush
* @param { number } except - Subscene that should ignore this request
*/
rglwidgetClass.prototype.clearBrush = function(except) {
if (this.select.subscene != except) {
this.select.state = "inactive";
this.delFromSubscene(this.scene.brushId, this.select.subscene);
}
this.drawScene();
};
/**
* Compute mouse coordinates relative to current canvas
* @returns { Object }
* @param { Object } event - event object from mouse click
*/
rglwidgetClass.prototype.relMouseCoords = function(event) {
var totalOffsetX = 0,
totalOffsetY = 0,
currentElement = this.canvas;
do {
totalOffsetX += currentElement.offsetLeft;
totalOffsetY += currentElement.offsetTop;
currentElement = currentElement.offsetParent;
}
while(currentElement);
var canvasX = event.pageX - totalOffsetX,
canvasY = event.pageY - totalOffsetY;
return {x:canvasX, y:canvasY};
};
/**
* Set mouse handlers for the scene
*/
rglwidgetClass.prototype.setMouseHandlers = function() {
var self = this, activeSubscene, handler,
handlers = {}, drag = 0;
handlers.rotBase = 0;
this.screenToVector = function(x, y) {
var viewport = this.getObj(activeSubscene).par3d.viewport,
width = viewport.width*this.canvas.width,
height = viewport.height*this.canvas.height,
radius = Math.max(width, height)/2.0,
cx = width/2.0,
cy = height/2.0,
px = (x-cx)/radius,
py = (y-cy)/radius,
plen = Math.sqrt(px*px+py*py);
if (plen > 1.e-6) {
px = px/plen;
py = py/plen;
}
var angle = (Math.SQRT2 - plen)/Math.SQRT2*Math.PI/2,
z = Math.sin(angle),
zlen = Math.sqrt(1.0 - z*z);
px = px * zlen;
py = py * zlen;
return [px, py, z];
};
handlers.trackballdown = function(x,y) {
var activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
i, l = activeModel.par3d.listeners;
handlers.rotBase = this.screenToVector(x, y);
this.saveMat = [];
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
}
};
handlers.trackballmove = function(x,y) {
var rotCurrent = this.screenToVector(x,y),
rotBase = handlers.rotBase,
dot = rotBase[0]*rotCurrent[0] +
rotBase[1]*rotCurrent[1] +
rotBase[2]*rotCurrent[2],
angle = Math.acos( dot/this.vlen(rotBase)/this.vlen(rotCurrent) )*180.0/Math.PI,
axis = this.xprod(rotBase, rotCurrent),
objects = this.scene.objects,
activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
l = activeModel.par3d.listeners,
i;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.par3d.userMatrix.load(objects[l[i]].saveMat);
activeSub.par3d.userMatrix.rotate(angle, axis[0], axis[1], axis[2]);
}
this.drawScene();
};
handlers.trackballend = 0;
this.clamp = function(x, lo, hi) {
return Math.max(lo, Math.min(x, hi));
};
this.screenToPolar = function(x,y) {
var viewport = this.getObj(activeSubscene).par3d.viewport,
width = viewport.width*this.canvas.width,
height = viewport.height*this.canvas.height,
r = Math.min(width, height)/2,
dx = this.clamp(x - width/2, -r, r),
dy = this.clamp(y - height/2, -r, r);
return [Math.asin(dx/r), Math.asin(-dy/r)];
};
handlers.polardown = function(x,y) {
var activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
i, l = activeModel.par3d.listeners;
handlers.dragBase = this.screenToPolar(x, y);
this.saveMat = [];
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
activeSub.camBase = [-Math.atan2(activeSub.saveMat.m13, activeSub.saveMat.m11),
Math.atan2(activeSub.saveMat.m32, activeSub.saveMat.m22)];
}
};
handlers.polarmove = function(x,y) {
var dragCurrent = this.screenToPolar(x,y),
activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
objects = this.scene.objects,
l = activeModel.par3d.listeners,
i, changepos = [];
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
for (j=0; j<2; j++)
changepos[j] = -(dragCurrent[j] - handlers.dragBase[j]);
activeSub.par3d.userMatrix.makeIdentity();
activeSub.par3d.userMatrix.rotate(changepos[0]*180/Math.PI, 0,-1,0);
activeSub.par3d.userMatrix.multRight(objects[l[i]].saveMat);
activeSub.par3d.userMatrix.rotate(changepos[1]*180/Math.PI, -1,0,0);
}
this.drawScene();
};
handlers.polarend = 0;
handlers.axisdown = function(x,y) {
handlers.rotBase = this.screenToVector(x, this.canvas.height/2);
var activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
i, l = activeModel.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
}
};
handlers.axismove = function(x,y) {
var rotCurrent = this.screenToVector(x, this.canvas.height/2),
rotBase = handlers.rotBase,
angle = (rotCurrent[0] - rotBase[0])*180/Math.PI,
rotMat = new CanvasMatrix4();
rotMat.rotate(angle, handlers.axis[0], handlers.axis[1], handlers.axis[2]);
var activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
i, l = activeModel.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.par3d.userMatrix.load(activeSub.saveMat);
activeSub.par3d.userMatrix.multLeft(rotMat);
}
this.drawScene();
};
handlers.axisend = 0;
handlers.y0zoom = 0;
handlers.zoom0 = 0;
handlers.zoomdown = function(x, y) {
var activeSub = this.getObj(activeSubscene),
activeProjection = this.getObj(this.useid(activeSub.id, "projection")),
i, l = activeProjection.par3d.listeners;
handlers.y0zoom = y;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.zoom0 = Math.log(activeSub.par3d.zoom);
}
};
handlers.zoommove = function(x, y) {
var activeSub = this.getObj(activeSubscene),
activeProjection = this.getObj(this.useid(activeSub.id, "projection")),
i, l = activeProjection.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.par3d.zoom = Math.exp(activeSub.zoom0 + (y-handlers.y0zoom)/this.canvas.height);
}
this.drawScene();
};
handlers.zoomend = 0;
handlers.y0fov = 0;
handlers.fovdown = function(x, y) {
handlers.y0fov = y;
var activeSub = this.getObj(activeSubscene),
activeProjection = this.getObj(this.useid(activeSub.id, "projection")),
i, l = activeProjection.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.fov0 = activeSub.par3d.FOV;
}
};
handlers.fovmove = function(x, y) {
var activeSub = this.getObj(activeSubscene),
activeProjection = this.getObj(this.useid(activeSub.id, "projection")),
i, l = activeProjection.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.par3d.FOV = Math.max(1, Math.min(179, activeSub.fov0 +
180*(y-handlers.y0fov)/this.canvas.height));
}
this.drawScene();
};
handlers.fovend = 0;
handlers.selectingdown = function(x, y) {
var viewport = this.getObj(activeSubscene).par3d.viewport,
width = viewport.width*this.canvas.width,
height = viewport.height*this.canvas.height, 
p = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
this.select.region = {p1: p, p2: p};
if (this.select.subscene && this.select.subscene != activeSubscene)
this.delFromSubscene(this.scene.brushId, this.select.subscene);
this.select.subscene = activeSubscene;
this.addToSubscene(this.scene.brushId, activeSubscene);
this.select.state = "changing";
if (typeof this.scene.brushId !== "undefined")
this.getObj(this.scene.brushId).initialized = false;
this.drawScene();
};
handlers.selectingmove = function(x, y) {
var viewport = this.getObj(activeSubscene).par3d.viewport,
width = viewport.width*this.canvas.width,
height = viewport.height*this.canvas.height;
if (this.select.state === "inactive") 
return;
this.select.region.p2 = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
if (typeof this.scene.brushId !== "undefined")
this.getObj(this.scene.brushId).initialized = false;
this.drawScene();
};
handlers.selectingend = 0;
this.canvas.onmousedown = function ( ev ){
if (!ev.which) // Use w3c defns in preference to MS
switch (ev.button) {
case 0: ev.which = 1; break;
case 1:
case 4: ev.which = 2; break;
case 2: ev.which = 3;
}
drag = ["left", "middle", "right"][ev.which-1];
var coords = self.relMouseCoords(ev);
coords.y = self.canvas.height-coords.y;
activeSubscene = self.whichSubscene(coords);
var sub = self.getObj(activeSubscene), f;
handler = sub.par3d.mouseMode[drag];
switch (handler) {
case "xAxis":
handler = "axis";
handlers.axis = [1.0, 0.0, 0.0];
break;
case "yAxis":
handler = "axis";
handlers.axis = [0.0, 1.0, 0.0];
break;
case "zAxis":
handler = "axis";
handlers.axis = [0.0, 0.0, 1.0];
break;
}
f = handlers[handler + "down"];
if (f) {
coords = self.translateCoords(activeSubscene, coords);
f.call(self, coords.x, coords.y);
ev.preventDefault();
} else
console.warn("Mouse handler '" + handler + "' is not implemented.");
};
this.canvas.onmouseup = function ( ev ){
if ( drag === 0 ) return;
var f = handlers[handler + "end"];
if (f) {
f.call(self);
ev.preventDefault();
}
drag = 0;
};
this.canvas.onmouseout = this.canvas.onmouseup;
this.canvas.onmousemove = function ( ev ) {
if ( drag === 0 ) return;
var f = handlers[handler + "move"];
if (f) {
var coords = self.relMouseCoords(ev);
coords.y = self.canvas.height - coords.y;
coords = self.translateCoords(activeSubscene, coords);
f.call(self, coords.x, coords.y);
}
};
handlers.wheelHandler = function(ev) {
var del = 1.02, i;
if (ev.shiftKey) del = 1.002;
var ds = ((ev.detail || ev.wheelDelta) > 0) ? del : (1 / del);
if (typeof activeSubscene === "undefined")
activeSubscene = self.scene.rootSubscene;
var activeSub = self.getObj(activeSubscene),
activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
l = activeProjection.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = self.getObj(l[i]);
activeSub.par3d.zoom *= ds;
}
self.drawScene();
ev.preventDefault();
};
this.canvas.addEventListener("DOMMouseScroll", handlers.wheelHandler, false);
this.canvas.addEventListener("mousewheel", handlers.wheelHandler, false);
};
/**
* Find a particular subscene by inheritance
* @returns { number } id of subscene to use
* @param { number } subsceneid - child subscene
* @param { string } type - type of inheritance:  "projection" or "model"
*/
rglwidgetClass.prototype.useid = function(subsceneid, type) {
var sub = this.getObj(subsceneid);
if (sub.embeddings[type] === "inherit")
return(this.useid(sub.parent, type));
else
return subsceneid;
};
/**
* Check whether point is in viewport of subscene
* @returns {boolean}
* @param { Object } coords - screen coordinates of point
* @param { number } subsceneid - subscene to check
*/
rglwidgetClass.prototype.inViewport = function(coords, subsceneid) {
var viewport = this.getObj(subsceneid).par3d.viewport,
x0 = coords.x - viewport.x*this.canvas.width,
y0 = coords.y - viewport.y*this.canvas.height;
return 0 <= x0 && x0 <= viewport.width*this.canvas.width &&
0 <= y0 && y0 <= viewport.height*this.canvas.height;
};
/**
* Find which subscene contains a point
* @returns { number } subscene id
* @param { Object } coords - coordinates of point
*/
rglwidgetClass.prototype.whichSubscene = function(coords) {
var self = this,
recurse = function(subsceneid) {
var subscenes = self.getChildSubscenes(subsceneid), i, id;
for (i=0; i < subscenes.length; i++) {
id = recurse(subscenes[i]);
if (typeof(id) !== "undefined")
return(id);
}
if (self.inViewport(coords, subsceneid))
return(subsceneid);
else
return undefined;
},
rootid = this.scene.rootSubscene,
result = recurse(rootid);
if (typeof(result) === "undefined")
result = rootid;
return result;
};
/**
* Translate from window coordinates to viewport coordinates
* @returns { Object } translated coordinates
* @param { number } subsceneid - which subscene to use?
* @param { Object } coords - point to translate
*/
rglwidgetClass.prototype.translateCoords = function(subsceneid, coords) {
var viewport = this.getObj(subsceneid).par3d.viewport;
return {x: coords.x - viewport.x*this.canvas.width,
y: coords.y - viewport.y*this.canvas.height};
};
/**
* Initialize the sphere object
*/
rglwidgetClass.prototype.initSphere = function() {
var verts = this.scene.sphereVerts,
reuse = verts.reuse, result;
if (typeof reuse !== "undefined") {
var prev = document.getElementById(reuse).rglinstance.sphere;
result = {values: prev.values, vOffsets: prev.vOffsets, it: prev.it};
} else
result = {values: new Float32Array(this.flatten(this.cbind(this.transpose(verts.vb),
this.transpose(verts.texcoords)))),
it: new Uint16Array(this.flatten(this.transpose(verts.it))),
vOffsets: {vofs:0, cofs:-1, nofs:-1, radofs:-1, oofs:-1,
tofs:3, nextofs:-1, pointofs:-1, stride:5}};
result.sphereCount = result.it.length;
this.sphere = result;
};
/**
* Set the vertices in the selection box object
*/
rglwidgetClass.prototype.initSelection = function(id) {
if (typeof this.select.region === "undefined")
return;
var obj = this.getObj(id),
width = this.canvas.width,
height = this.canvas.height, 
p1 = this.select.region.p1,
p2 = this.select.region.p2;
obj.vertices = [[p1.x, p1.y, 0.0],
[p2.x, p1.y, 0.0],
[p2.x, p2.y, 0.0],
[p1.x, p2.y, 0.0],
[p1.x, p1.y, 0.0]];
};
/**
* Do the gl part of initializing the sphere
*/
rglwidgetClass.prototype.initSphereGL = function() {
var gl = this.gl || this.initGL(), sphere = this.sphere;
if (gl.isContextLost()) return;
sphere.buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, sphere.buf);
gl.bufferData(gl.ARRAY_BUFFER, sphere.values, gl.STATIC_DRAW);
sphere.ibuf = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphere.ibuf);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.it, gl.STATIC_DRAW);
return;
};
/**
* Initialize the DOM object
* @param { Object } el - the DOM object
* @param { Object } x - the scene data sent by JSON from R
*/
rglwidgetClass.prototype.initialize = function(el, x) {
this.textureCanvas = document.createElement("canvas");
this.textureCanvas.style.display = "block";
this.scene = x;
this.normMatrix = new CanvasMatrix4();
this.saveMat = {};
this.distance = null;
this.posLoc = 0;
this.colLoc = 1;
if (el) {
el.rglinstance = this;
this.el = el;
this.webGLoptions = el.rglinstance.scene.webGLoptions;
this.initCanvas();
}
if (typeof Shiny !== "undefined") {
var self = this;
Shiny.addCustomMessageHandler("shinyGetPar3d",
function(message) {
var i, param, 
subscene = self.getObj(message.subscene),
parameters = [].concat(message.parameters),
result = {tag: message.tag, subscene: message.subscene};
if (typeof subscene !== "undefined") {
for (i = 0; i < parameters.length; i++) {
param = parameters[i];
result[param] = subscene.par3d[param];
};
} else {
console.log("subscene "+message.subscene+" undefined.")
}
Shiny.setInputValue("par3d:shinyPar3d", result, {priority: "event"});
});
Shiny.addCustomMessageHandler("shinySetPar3d",
function(message) {
var param = message.parameter, 
subscene = self.getObj(message.subscene);
if (typeof subscene !== "undefined") {
subscene.par3d[param] = message.value;
subscene.initialized = false;
self.drawScene();
} else {
console.log("subscene "+message.subscene+" undefined.")
}
})
}
};
/**
* Restart the WebGL canvas
*/
rglwidgetClass.prototype.restartCanvas = function() {
var newcanvas = document.createElement("canvas"),
self = this;
newcanvas.width = this.el.width;
newcanvas.height = this.el.height;
newcanvas.addEventListener("webglcontextrestored",
this.onContextRestored, false);
newcanvas.addEventListener("webglcontextlost",
this.onContextLost, false);
while (this.el.firstChild) {
this.el.removeChild(this.el.firstChild);
}
this.el.appendChild(newcanvas);
this.canvas = newcanvas;
this.setMouseHandlers();
if (this.gl) 
Object.keys(this.scene.objects).forEach(function(key){
self.getObj(parseInt(key, 10)).texture = undefined; 
});
this.gl = null;
};
/**
* Initialize the WebGL canvas
*/
rglwidgetClass.prototype.initCanvas = function() {
this.restartCanvas();
var objs = this.scene.objects,
self = this;
Object.keys(objs).forEach(function(key){
var id = parseInt(key, 10),
obj = self.getObj(id);
if (typeof obj.reuse !== "undefined")
self.copyObj(id, obj.reuse);
});
Object.keys(objs).forEach(function(key){
self.initSubscene(parseInt(key, 10));
});
this.setMouseHandlers();
this.initSphere();
this.onContextRestored = function(event) {
self.initGL();
self.drawScene();
};
this.onContextLost = function(event) {
if (!self.drawing)
this.gl = null;
event.preventDefault();
};
this.initGL0();
this.lazyLoadScene = function() {
if (typeof self.slide === "undefined")
self.slide = self.getSlide();
if (self.isInBrowserViewport()) {
if (!self.gl || self.gl.isContextLost())
self.initGL();
self.drawScene();
}
};
window.addEventListener("DOMContentLoaded", this.lazyLoadScene, false);
window.addEventListener("load", this.lazyLoadScene, false);
window.addEventListener("resize", this.lazyLoadScene, false);
window.addEventListener("scroll", this.lazyLoadScene, false);
this.slide = this.getSlide();
if (this.slide) {
if (typeof this.slide.rgl === "undefined")
this.slide.rgl = [this];
else
this.slide.rgl.push(this);
if (this.scene.context.rmarkdown) 
if (this.scene.context.rmarkdown === "ioslides_presentation") {
this.slide.setAttribute("slideenter", "this.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window);})");
} else if (this.scene.context.rmarkdown === "slidy_presentation") {
// This method would also work in ioslides, but it gets triggered
// something like 5 times per slide for every slide change, so
// you'd need a quicker function than lazyLoadScene.
var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver,
observer = new MutationObserver(function(mutations) {
mutations.forEach(function(mutation) {
self.slide.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window); });});});
observer.observe(this.slide, { attributes: true, attributeFilter:["class"] });
}
}
};
/**
* Start the writeWebGL scene. This is only used by writeWebGL; rglwidget has
no debug element and does the drawing in rglwidget.js.
*/
rglwidgetClass.prototype.start = function() {
if (typeof this.prefix !== "undefined") {
this.debugelement = document.getElementById(this.prefix + "debug");
this.debug("");
}
this.drag = 0;
this.drawScene();
};
/**
* Display a debug message
* @param { string } msg - The message to display
* @param { Object } [img] - Image to insert before message
*/
rglwidgetClass.prototype.debug = function(msg, img) {
if (typeof this.debugelement !== "undefined" && this.debugelement !== null) {
this.debugelement.innerHTML = msg;
if (typeof img !== "undefined") {
this.debugelement.insertBefore(img, this.debugelement.firstChild);
}
} else if (msg !== "")
alert(msg);
};
/**
* Get the snapshot image of this scene
* @returns { Object } The img DOM element
*/
rglwidgetClass.prototype.getSnapshot = function() {
var img;
if (typeof this.scene.snapshot !== "undefined") {
img = document.createElement("img");
img.src = this.scene.snapshot;
img.alt = "Snapshot";
}
return img;
};
/**
* Initial test for WebGL
*/
rglwidgetClass.prototype.initGL0 = function() {
if (!window.WebGLRenderingContext){
alert("Your browser does not support WebGL. See http://get.webgl.org");
return;
}
};
/**
* If we are in an ioslides or slidy presentation, get the
* DOM element of the current slide
* @returns { Object }
*/
rglwidgetClass.prototype.getSlide = function() {
var result = this.el, done = false;
while (result && !done && this.scene.context.rmarkdown) {
switch(this.scene.context.rmarkdown) {
case "ioslides_presentation":
if (result.tagName === "SLIDE") return result;
break;
case "slidy_presentation":
if (result.tagName === "DIV" && result.classList.contains("slide"))
return result;
break;
default: return null;
}
result = result.parentElement;
}
return null;
};
/**
* Is this scene visible in the browser?
* @returns { boolean }
*/
rglwidgetClass.prototype.isInBrowserViewport = function() {
var rect = this.canvas.getBoundingClientRect(),
windHeight = (window.innerHeight || document.documentElement.clientHeight),
windWidth = (window.innerWidth || document.documentElement.clientWidth);
if (this.scene.context && this.scene.context.rmarkdown !== null) {
if (this.slide)
return (this.scene.context.rmarkdown === "ioslides_presentation" &&
this.slide.classList.contains("current")) ||
(this.scene.context.rmarkdown === "slidy_presentation" &&
!this.slide.classList.contains("hidden"));
}
return (
rect.top >= -windHeight &&
rect.left >= -windWidth &&
rect.bottom <= 2*windHeight &&
rect.right <= 2*windWidth);
};
/**
* Initialize WebGL
* @returns { Object } the WebGL context
*/
rglwidgetClass.prototype.initGL = function() {
var self = this;
if (this.gl) {
if (!this.drawing && this.gl.isContextLost())
this.restartCanvas();
else
return this.gl;
}
// if (!this.isInBrowserViewport()) return; Return what??? At this point we know this.gl is null.
this.canvas.addEventListener("webglcontextrestored",
this.onContextRestored, false);
this.canvas.addEventListener("webglcontextlost",
this.onContextLost, false);
this.gl = this.canvas.getContext("webgl", this.webGLoptions) ||
this.canvas.getContext("experimental-webgl", this.webGLoptions);
this.index_uint = this.gl.getExtension("OES_element_index_uint");
var save = this.startDrawing();
this.initSphereGL();
Object.keys(this.scene.objects).forEach(function(key){
self.initObj(parseInt(key, 10));
});
this.stopDrawing(save);
return this.gl;
};
/**
* Resize the display to match element
* @param { Object } el - DOM element to match
*/
rglwidgetClass.prototype.resize = function(el) {
this.canvas.width = el.width;
this.canvas.height = el.height;
};
/**
* Draw the whole scene
*/
rglwidgetClass.prototype.drawScene = function() {
var gl = this.gl || this.initGL(),
wasDrawing = this.startDrawing();
if (!wasDrawing) {
if (this.select.state !== "inactive")
this.selectionChanged();
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL);
gl.clearDepth(1.0);
gl.clearColor(1,1,1,1);
gl.depthMask(true); // Must be true before clearing depth buffer
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
this.drawSubscene(this.scene.rootSubscene, true);
this.drawSubscene(this.scene.rootSubscene, false);
}
this.stopDrawing(wasDrawing);
};
/**
* Change the displayed subset
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The subset control data.
*/
rglwidgetClass.prototype.subsetSetter = function(el, control) {
if (typeof control.subscenes === "undefined" ||
control.subscenes === null)
control.subscenes = this.scene.rootSubscene;
var value = Math.round(control.value),
subscenes = [].concat(control.subscenes),
fullset = [].concat(control.fullset),
i, j, entries, subsceneid,
adds = [], deletes = [],
ismissing = function(x) {
return fullset.indexOf(x) < 0;
},
tointeger = function(x) {
return parseInt(x, 10);
};
if (isNaN(value))
value = control.value = 0;
if (control.accumulate)
for (i=0; i <= value; i++)
adds = adds.concat(control.subsets[i]);
else
adds = adds.concat(control.subsets[value]);
deletes = fullset.filter(function(x) { return adds.indexOf(x) < 0; });
for (i = 0; i < subscenes.length; i++) {
subsceneid = subscenes[i];
if (typeof this.getObj(subsceneid) === "undefined")
this.alertOnce("typeof object is undefined");
for (j = 0; j < adds.length; j++)
this.addToSubscene(adds[j], subsceneid);
for (j = 0; j < deletes.length; j++)
this.delFromSubscene(deletes[j], subsceneid);
}
};
/**
* Change the requested property
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The property setter control data.
*/
rglwidgetClass.prototype.propertySetter = function(el, control)  {
var value = control.value,
values = [].concat(control.values),
svals = [].concat(control.param),
direct = values[0] === null,
entries = [].concat(control.entries),
ncol = entries.length,
nrow = values.length/ncol,
properties = this.repeatToLen(control.properties, ncol),
objids = this.repeatToLen(control.objids, ncol),
property, objid = objids[0],
obj = this.getObj(objid),
propvals, i, v1, v2, p, entry, gl, needsBinding,
newprop, newid,
getPropvals = function() {
if (property === "userMatrix")
return obj.par3d.userMatrix.getAsArray();
else if (property === "scale" || property === "FOV" || property === "zoom")
return [].concat(obj.par3d[property]);
else
return [].concat(obj[property]);
};
putPropvals = function(newvals) {
if (newvals.length == 1)
newvals = newvals[0];
if (property === "userMatrix")
obj.par3d.userMatrix.load(newvals);
else if (property === "scale" || property === "FOV" || property === "zoom")
obj.par3d[property] = newvals;
else
obj[property] = newvals;
};
if (direct && typeof value === "undefined")
return;
if (control.interp) {
values = values.slice(0, ncol).concat(values).
concat(values.slice(ncol*(nrow-1), ncol*nrow));
svals = [-Infinity].concat(svals).concat(Infinity);
for (i = 1; i < svals.length; i++) {
if (value <= svals[i]) {
if (svals[i] === Infinity)
p = 1;
else
p = (svals[i] - value)/(svals[i] - svals[i-1]);
break;
}
}
} else if (!direct) {
value = Math.round(value);
}
for (j=0; j<entries.length; j++) {
entry = entries[j];
newprop = properties[j];
newid = objids[j];
if (newprop !== property || newid != objid) {
if (typeof property !== "undefined")
putPropvals(propvals);
property = newprop;
objid = newid;
obj = this.getObj(objid);
propvals = getPropvals();
}
if (control.interp) {
v1 = values[ncol*(i-1) + j];
v2 = values[ncol*i + j];
this.setElement(propvals, entry, p*v1 + (1-p)*v2);
} else if (!direct) {
this.setElement(propvals, entry, values[ncol*value + j]);
} else {
this.setElement(propvals, entry, value[j]);
}
}
putPropvals(propvals);
needsBinding = [];
for (j=0; j < entries.length; j++) {
if (properties[j] === "values" &&
needsBinding.indexOf(objids[j]) === -1) {
needsBinding.push(objids[j]);
}
}
for (j=0; j < needsBinding.length; j++) {
gl = this.gl || this.initGL();
obj = this.getObj(needsBinding[j]);
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
}
};
/**
* Change the requested vertices
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The vertext setter control data.
*/
rglwidgetClass.prototype.vertexSetter = function(el, control)  {
var svals = [].concat(control.param),
j, k, p, a, propvals, stride, ofs, obj, entry,
attrib,
ofss    = {x:"vofs", y:"vofs", z:"vofs",
red:"cofs", green:"cofs", blue:"cofs",
alpha:"cofs", radii:"radofs",
nx:"nofs", ny:"nofs", nz:"nofs",
ox:"oofs", oy:"oofs", oz:"oofs",
ts:"tofs", tt:"tofs"},
pos     = {x:0, y:1, z:2,
red:0, green:1, blue:2,
alpha:3,radii:0,
nx:0, ny:1, nz:2,
ox:0, oy:1, oz:2,
ts:0, tt:1},
values = control.values,
direct = values === null,
ncol,
interp = control.interp,
vertices = [].concat(control.vertices),
attributes = [].concat(control.attributes),
value = control.value, newval, aliases, alias;
ncol = Math.max(vertices.length, attributes.length);
if (!ncol)
return;
vertices = this.repeatToLen(vertices, ncol);
attributes = this.repeatToLen(attributes, ncol);
if (direct)
interp = false;
/* JSON doesn't pass Infinity */
svals[0] = -Infinity;
svals[svals.length - 1] = Infinity;
for (j = 1; j < svals.length; j++) {
if (value <= svals[j]) {
if (interp) {
if (svals[j] === Infinity)
p = 1;
else
p = (svals[j] - value)/(svals[j] - svals[j-1]);
} else {
if (svals[j] - value > value - svals[j-1])
j = j - 1;
}
break;
}
}
obj = this.getObj(control.objid);
// First, make sure color attributes vary in original
if (typeof obj.vOffsets !== "undefined") {
varies = true;
for (k = 0; k < ncol; k++) {
attrib = attributes[k];
if (typeof attrib !== "undefined") {
ofs = obj.vOffsets[ofss[attrib]];
if (ofs < 0) {
switch(attrib) {
case "alpha":
case "red":
case "green":
case "blue":
obj.colors = [obj.colors[0], obj.colors[0]];
break;
}
varies = false;
}
}
}
if (!varies)
this.initObj(control.objid);
}
propvals = obj.values;
aliases = obj.alias;
if (typeof aliases === "undefined")
aliases = [];
for (k=0; k<ncol; k++) {
if (direct) {
newval = value;
} else if (interp) {
newval = p*values[j-1][k] + (1-p)*values[j][k];
} else {
newval = values[j][k];
}       
attrib = attributes[k];
vertex = vertices[k];
alias = aliases[vertex];
if (obj.type === "planes" || obj.type === "clipplanes") {
ofs = ["nx", "ny", "nz", "offset"].indexOf(attrib);
if (ofs >= 0) {
if (ofs < 3) {
if (obj.normals[vertex][ofs] != newval) {  // Assume no aliases here...
obj.normals[vertex][ofs] = newval;
obj.initialized = false;
}
} else {
if (obj.offsets[vertex][0] != newval) {
obj.offsets[vertex][0] = newval;
obj.initialized = false;
}
}
continue;
}
}
// Not a plane setting...
ofs = obj.vOffsets[ofss[attrib]];
if (ofs < 0)
this.alertOnce("Attribute '"+attrib+"' not found in object "+control.objid);
else {
stride = obj.vOffsets.stride;
ofs = ofs + pos[attrib];
entry = vertex*stride + ofs;
propvals[entry] = newval;
if (typeof alias !== "undefined")
for (a = 0; a < alias.length; a++)
propvals[alias[a]*stride + ofs] = newval;
}
}
if (typeof obj.buf !== "undefined") {
var gl = this.gl || this.initGL();
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
gl.bufferData(gl.ARRAY_BUFFER, propvals, gl.STATIC_DRAW);
}
};
/**
* Change the requested vertex properties by age
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The age setter control data.
*/
rglwidgetClass.prototype.ageSetter = function(el, control) {
var objids = [].concat(control.objids),
nobjs = objids.length,
time = control.value,
births = [].concat(control.births),
ages = [].concat(control.ages),
steps = births.length,
j = Array(steps),
p = Array(steps),
i, k, age, j0, propvals, stride, ofs, objid, obj,
attrib, dim, varies, alias, aliases, a, d,
attribs = ["colors", "alpha", "radii", "vertices",
"normals", "origins", "texcoords",
"x", "y", "z",
"red", "green", "blue"],
ofss    = ["cofs", "cofs", "radofs", "vofs",
"nofs", "oofs", "tofs",
"vofs", "vofs", "vofs",
"cofs", "cofs", "cofs"],
dims    = [3,1,1,3,
3,2,2,
1,1,1,
1,1,1],
pos     = [0,3,0,0,
0,0,0,
0,1,2,
0,1,2];
/* Infinity doesn't make it through JSON */
ages[0] = -Infinity;
ages[ages.length-1] = Infinity;
for (i = 0; i < steps; i++) {
if (births[i] !== null) {  // NA in R becomes null
age = time - births[i];
for (j0 = 1; age > ages[j0]; j0++);
if (ages[j0] == Infinity)
p[i] = 1;
else if (ages[j0] > ages[j0-1])
p[i] = (ages[j0] - age)/(ages[j0] - ages[j0-1]);
else
p[i] = 0;
j[i] = j0;
}
}
// First, make sure color attributes vary in original
for (l = 0; l < nobjs; l++) {
objid = objids[l];
obj = this.getObj(objid);
varies = true;
if (typeof obj.vOffsets === "undefined")
continue;
for (k = 0; k < attribs.length; k++) {
attrib = control[attribs[k]];
if (typeof attrib !== "undefined") {
ofs = obj.vOffsets[ofss[k]];
if (ofs < 0) {
switch(attribs[k]) {
case "colors":
case "alpha":
case "red":
case "green":
case "blue":
obj.colors = [obj.colors[0], obj.colors[0]];
break;
}
varies = false;
}
}
}
if (!varies)
this.initObj(objid);
}
for (l = 0; l < nobjs; l++) {
objid = objids[l];
obj = this.getObj(objid);
if (typeof obj.vOffsets === "undefined")
continue;
aliases = obj.alias;
if (typeof aliases === "undefined")
aliases = [];
propvals = obj.values;
stride = obj.vOffsets.stride;
for (k = 0; k < attribs.length; k++) {
attrib = control[attribs[k]];
if (typeof attrib !== "undefined") {
ofs = obj.vOffsets[ofss[k]];
if (ofs >= 0) {
dim = dims[k];
ofs = ofs + pos[k];
for (i = 0; i < steps; i++) {
alias = aliases[i];
if (births[i] !== null) {
for (d=0; d < dim; d++) {
propvals[i*stride + ofs + d] = p[i]*attrib[dim*(j[i]-1) + d] + (1-p[i])*attrib[dim*j[i] + d];
if (typeof alias !== "undefined")
for (a=0; a < alias.length; a++)
propvals[alias[a]*stride + ofs + d] = propvals[i*stride + ofs + d];
}
}
}
} else
this.alertOnce("\'"+attribs[k]+"\' property not found in object "+objid);
}
}
obj.values = propvals;
if (typeof obj.buf !== "undefined") {
gl = this.gl || this.initGL();
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
}
}
};
/**
* Bridge to old style control
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The bridge control data.
*/
rglwidgetClass.prototype.oldBridge = function(el, control) {
var attrname, global = window[control.prefix + "rgl"];
if (global)
for (attrname in global)
this[attrname] = global[attrname];
window[control.prefix + "rgl"] = this;
};
/**
* Set up a player control
* @param { Object } el - The player control element
* @param { Object } control - The player data.
*/
rglwidgetClass.prototype.Player = function(el, control) {
var
self = this,
components = [].concat(control.components),
buttonLabels = [].concat(control.buttonLabels),
Tick = function() { /* "this" will be a timer */
var i,
nominal = this.value,
slider = this.Slider,
labels = this.outputLabels,
output = this.Output,
step;
if (typeof slider !== "undefined" && nominal != slider.value)
slider.value = nominal;
if (typeof output !== "undefined") {
step = Math.round((nominal - output.sliderMin)/output.sliderStep);
if (labels !== null) {
output.innerHTML = labels[step];
} else {
step = step*output.sliderStep + output.sliderMin;
output.innerHTML = step.toPrecision(output.outputPrecision);
}
}
for (i=0; i < this.actions.length; i++) {
this.actions[i].value = nominal;
}
self.applyControls(el, this.actions, false);
self.drawScene();
},
OnSliderInput = function() { /* "this" will be the slider */
this.rgltimer.value = Number(this.value);
this.rgltimer.Tick();
},
addSlider = function(min, max, step, value) {
var slider = document.createElement("input");
slider.type = "range";
slider.min = min;
slider.max = max;
slider.step = step;
slider.value = value;
slider.oninput = OnSliderInput;
slider.sliderActions = control.actions;
slider.sliderScene = this;
slider.className = "rgl-slider";
slider.id = el.id + "-slider";
el.rgltimer.Slider = slider;
slider.rgltimer = el.rgltimer;
el.appendChild(slider);
},
addLabel = function(labels, min, step, precision) {
var output = document.createElement("output");
output.sliderMin = min;
output.sliderStep = step;
output.outputPrecision = precision;
output.className = "rgl-label";
output.id = el.id + "-label";
el.rgltimer.Output = output;
el.rgltimer.outputLabels = labels;
el.appendChild(output);
},
addButton = function(which, label, active) {
var button = document.createElement("input"),
onclicks = {Reverse: function() { this.rgltimer.reverse();},
Play: function() { this.rgltimer.play();
this.value = this.rgltimer.enabled ? this.inactiveValue : this.activeValue; },
Slower: function() { this.rgltimer.slower(); },
Faster: function() { this.rgltimer.faster(); },
Reset: function() { this.rgltimer.reset(); },
Step:  function() { this.rgltimer.step(); }
};
button.rgltimer = el.rgltimer;
button.type = "button";
button.value = label;
button.activeValue = label;
button.inactiveValue = active;
if (which === "Play")
button.rgltimer.PlayButton = button;
button.onclick = onclicks[which];
button.className = "rgl-button";
button.id = el.id + "-" + which;
el.appendChild(button);
};
if (typeof control.reinit !== "undefined" && control.reinit !== null) {
control.actions.reinit = control.reinit;
}
el.rgltimer = new rgltimerClass(Tick, control.start, control.interval, control.stop,
control.step, control.value, control.rate, control.loop, control.actions);
for (var i=0; i < components.length; i++) {
switch(components[i]) {
case "Slider": addSlider(control.start, control.stop,
control.step, control.value);
break;
case "Label": addLabel(control.labels, control.start,
control.step, control.precision);
break;
default:
addButton(components[i], buttonLabels[i], control.pause);
}
}
el.rgltimer.Tick();
};
/**
* Apply all registered controls
* @param { Object } el - DOM element of the control
* @param { Object } x - List of actions to apply
* @param { boolean } [draw=true] - Whether to redraw after applying
*/
rglwidgetClass.prototype.applyControls = function(el, x, draw) {
var self = this, reinit = x.reinit, i, control, type;
for (i = 0; i < x.length; i++) {
control = x[i];
type = control.type;
self[type](el, control);
}
if (typeof reinit !== "undefined" && reinit !== null) {
reinit = [].concat(reinit);
for (i = 0; i < reinit.length; i++)
self.getObj(reinit[i]).initialized = false;
}
if (typeof draw === "undefined" || draw)
self.drawScene();
};
/**
* Handler for scene change
* @param { Object } message - What sort of scene change to do?
*/
rglwidgetClass.prototype.sceneChangeHandler = function(message) {
var self = document.getElementById(message.elementId).rglinstance,
objs = message.objects, mat = message.material,
root = message.rootSubscene,
initSubs = message.initSubscenes,
redraw = message.redrawScene,
skipRedraw = message.skipRedraw,
deletes, subs, allsubs = [], i,j;
if (typeof message.delete !== "undefined") {
deletes = [].concat(message.delete);
if (typeof message.delfromSubscenes !== "undefined")
subs = [].concat(message.delfromSubscenes);
else
subs = [];
for (i = 0; i < deletes.length; i++) {
for (j = 0; j < subs.length; j++) {
self.delFromSubscene(deletes[i], subs[j]);
}
delete self.scene.objects[deletes[i]];
}
}
if (typeof objs !== "undefined") {
Object.keys(objs).forEach(function(key){
key = parseInt(key, 10);
self.scene.objects[key] = objs[key];
self.initObj(key);
var obj = self.getObj(key),
subs = [].concat(obj.inSubscenes), k;
allsubs = allsubs.concat(subs);
for (k = 0; k < subs.length; k++)
self.addToSubscene(key, subs[k]);
});
}
if (typeof mat !== "undefined") {
self.scene.material = mat;
}
if (typeof root !== "undefined") {
self.scene.rootSubscene = root;
}
if (typeof initSubs !== "undefined")
allsubs = allsubs.concat(initSubs);
allsubs = self.unique(allsubs);
for (i = 0; i < allsubs.length; i++) {
self.initSubscene(allsubs[i]);
}
if (typeof skipRedraw !== "undefined") {
root = self.getObj(self.scene.rootSubscene);
root.par3d.skipRedraw = skipRedraw;
}
if (redraw)
self.drawScene();
};
/**
* Set mouse mode for a subscene
* @param { string } mode - name of mode
* @param { number } button - button number (1 to 3)
* @param { number } subscene - subscene id number
* @param { number } stayActive - if truthy, don't clear brush
*/
rglwidgetClass.prototype.setMouseMode = function(mode, button, subscene, stayActive) {
var sub = this.getObj(subscene),
which = ["left", "right", "middle"][button - 1];
if (!stayActive && sub.par3d.mouseMode[which] === "selecting")
this.clearBrush(null);
sub.par3d.mouseMode[which] = mode;
};
/**
* The class of an rgl timer object
* @class
*/
/**
* Construct an rgltimerClass object
* @constructor
* @param { function } Tick - action when timer fires
* @param { number } startTime - nominal start time in seconds
* @param { number } interval - seconds between updates
* @param { number } stopTime - nominal stop time in seconds
* @param { number } stepSize - nominal step size
* @param { number } value - current nominal time
* @param { number } rate - nominal units per second
* @param { string } loop - "none", "cycle" or "oscillate"
* @param { Object } actions - list of actions
*/
rgltimerClass = function(Tick, startTime, interval, stopTime, stepSize, value, rate, loop, actions) {
this.enabled = false;
this.timerId = 0;
/** nominal start time in seconds */
this.startTime = startTime;   
/** current nominal time */      
this.value = value;
/** seconds between updates */                 
this.interval = interval;
/** nominal stop time */           
this.stopTime = stopTime;
/** nominal step size */           
this.stepSize = stepSize;
/** nominal units per second */           
this.rate = rate;
/** "none", "cycle", or "oscillate" */                   
this.loop = loop;
/** real world start time */                   
this.realStart = undefined;
/** multiplier for fast-forward or reverse */         
this.multiplier = 1;                
this.actions = actions;
this.Tick = Tick;
};
/**
* Start playing timer object
*/
rgltimerClass.prototype.play = function() {
if (this.enabled) {
this.enabled = false;
window.clearInterval(this.timerId);
this.timerId = 0;
return;
}
var tick = function(self) {
var now = new Date();
self.value = self.multiplier*self.rate*(now - self.realStart)/1000 + self.startTime;
self.forceToRange();
if (typeof self.Tick !== "undefined") {
self.Tick(self.value);
}
};
this.realStart = new Date() - 1000*(this.value - this.startTime)/this.rate/this.multiplier;
this.timerId = window.setInterval(tick, 1000*this.interval, this);
this.enabled = true;
};
/**
* Force value into legal range
*/
rgltimerClass.prototype.forceToRange = function() {
if (this.value > this.stopTime + this.stepSize/2 || this.value < this.startTime - this.stepSize/2) {
if (!this.loop) {
this.reset();
} else {
var cycle = this.stopTime - this.startTime + this.stepSize,
newval = (this.value - this.startTime) % cycle + this.startTime;
if (newval < this.startTime) {
newval += cycle;
}
this.realStart += (this.value - newval)*1000/this.multiplier/this.rate;
this.value = newval;
}
}
};
/**
* Reset to start values
*/
rgltimerClass.prototype.reset = function() {
this.value = this.startTime;
this.newmultiplier(1);
if (typeof this.Tick !== "undefined") {
this.Tick(this.value);
}
if (this.enabled)
this.play();  /* really pause... */
if (typeof this.PlayButton !== "undefined")
this.PlayButton.value = "Play";
};
/**
* Increase the multiplier to play faster
*/
rgltimerClass.prototype.faster = function() {
this.newmultiplier(Math.SQRT2*this.multiplier);
};
/**
* Decrease the multiplier to play slower
*/
rgltimerClass.prototype.slower = function() {
this.newmultiplier(this.multiplier/Math.SQRT2);
};
/**
* Change sign of multiplier to reverse direction
*/
rgltimerClass.prototype.reverse = function() {
this.newmultiplier(-this.multiplier);
};
/**
* Set multiplier for play speed
* @param { number } newmult - new value
*/
rgltimerClass.prototype.newmultiplier = function(newmult) {
if (newmult != this.multiplier) {
this.realStart += 1000*(this.value - this.startTime)/this.rate*(1/this.multiplier - 1/newmult);
this.multiplier = newmult;
}
};
/**
* Take one step
*/
rgltimerClass.prototype.step = function() {
this.value += this.rate*this.multiplier;
this.forceToRange();
if (typeof this.Tick !== "undefined")
this.Tick(this.value);
};</script>
<div id="_04_splsda_3ddiv" class="rglWebGL">

</div>
<script type="text/javascript">
var _04_splsda_3ddiv = document.getElementById("_04_splsda_3ddiv"),
_04_splsda_3drgl = new rglwidgetClass();
_04_splsda_3ddiv.width = 701;
_04_splsda_3ddiv.height = 701;
_04_splsda_3drgl.initialize(_04_splsda_3ddiv,
{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":false,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0]},"rootSubscene":1,"objects":{"7":{"id":7,"type":"text","material":{"lit":false},"vertices":[[-1.333194,-2.577876,-0.525881],[-0.4341875,-2.864505,-0.2169086],[-0.9293166,-2.350373,-0.8383132],[-0.8272399,-3.399329,-0.3938814],[-0.6285741,-2.327025,0.04259178],[-0.8131436,-3.219754,-0.3072716],[0.1348152,-3.031554,-0.1533689],[-0.5318992,-2.911762,-0.345827],[-1.23503,-4.568926,0.06926445],[0.00820661,-1.787174,-0.6754655],[-1.097046,-3.088807,-0.3332818],[-0.6872076,-3.351568,0.3131501],[-0.379131,-3.709943,-0.4814033],[-0.3582196,-4.110731,0.9008526],[-1.209285,-1.119073,0.7130926],[-1.09914,-0.7159439,0.9713877],[-0.5534112,-1.062893,0.1410254],[-0.4062183,-2.06328,-0.003309421],[-0.5370578,-2.759448,-0.008498785],[-1.685362,-4.261372,1.116179],[-1.508933,-1.910483,0.8910605],[-0.6824031,-1.664872,0.4440114],[-1.180854,-1.71006,-0.04149]],"colors":[[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1],[0.2196078,0.5568628,0.8,1]],"texts":[["EWS.T1"],["EWS.T2"],["EWS.T3"],["EWS.T4"],["EWS.T6"],["EWS.T7"],["EWS.T9"],["EWS.T11"],["EWS.T12"],["EWS.T13"],["EWS.T14"],["EWS.T15"],["EWS.T19"],["EWS.C8"],["EWS.C3"],["EWS.C2"],["EWS.C4"],["EWS.C6"],["EWS.C9"],["EWS.C7"],["EWS.C1"],["EWS.C11"],["EWS.C10"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[-1.333194,-2.577876,-0.525881],[-0.4341875,-2.864505,-0.2169086],[-0.9293166,-2.350373,-0.8383132],[-0.8272399,-3.399329,-0.3938814],[-0.6285741,-2.327025,0.04259178],[-0.8131436,-3.219754,-0.3072716],[0.1348152,-3.031554,-0.1533689],[-0.5318992,-2.911762,-0.345827],[-1.23503,-4.568926,0.06926445],[0.00820661,-1.787174,-0.6754655],[-1.097046,-3.088807,-0.3332818],[-0.6872076,-3.351568,0.3131501],[-0.379131,-3.709943,-0.4814033],[-0.3582196,-4.110731,0.9008526],[-1.209285,-1.119073,0.7130926],[-1.09914,-0.7159439,0.9713877],[-0.5534112,-1.062893,0.1410254],[-0.4062183,-2.06328,-0.003309421],[-0.5370578,-2.759448,-0.008498785],[-1.685362,-4.261372,1.116179],[-1.508933,-1.910483,0.8910605],[-0.6824031,-1.664872,0.4440114],[-1.180854,-1.71006,-0.04149]],"family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":2064},"8":{"id":8,"type":"text","material":{"lit":false},"vertices":[[7.327461,0.3982642,-0.2233262],[4.814378,0.7468746,0.6194044],[7.973598,0.3477017,0.2270208],[7.097607,0.433485,0.1162216],[6.29603,0.6924437,0.03986873],[5.894866,0.5885199,0.3031493],[8.074144,0.1319681,0.2119994],[8.504086,0.1509317,0.5045338]],"colors":[[0.9647059,0.5450981,0.2,1],[0.9647059,0.5450981,0.2,1],[0.9647059,0.5450981,0.2,1],[0.9647059,0.5450981,0.2,1],[0.9647059,0.5450981,0.2,1],[0.9647059,0.5450981,0.2,1],[0.9647059,0.5450981,0.2,1],[0.9647059,0.5450981,0.2,1]],"texts":[["BL.C5"],["BL.C6"],["BL.C7"],["BL.C8"],["BL.C1"],["BL.C2"],["BL.C3"],["BL.C4"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[7.327461,0.3982642,-0.2233262],[4.814378,0.7468746,0.6194044],[7.973598,0.3477017,0.2270208],[7.097607,0.433485,0.1162216],[6.29603,0.6924437,0.03986873],[5.894866,0.5885199,0.3031493],[8.074144,0.1319681,0.2119994],[8.504086,0.1509317,0.5045338]],"family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":2064},"9":{"id":9,"type":"text","material":{"lit":false},"vertices":[[-1.085535,1.980763,2.04358],[-0.7596992,1.697731,2.738638],[-1.009635,1.965032,1.726025],[-1.897706,2.016882,1.528964],[-1.988084,1.837308,4.325223],[-1.555121,1.336137,1.327028],[-1.052586,2.1255,2.261516],[-1.405859,2.445933,2.212653],[-1.352712,1.968986,3.213165],[-1.979912,1.821023,0.9059321],[-1.425513,1.606863,2.766967],[-1.909455,2.270738,0.6683522]],"colors":[[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1],[0.7607843,0.7607843,0.7607843,1]],"texts":[["NB.C1"],["NB.C2"],["NB.C3"],["NB.C6"],["NB.C12"],["NB.C7"],["NB.C4"],["NB.C5"],["NB.C10"],["NB.C11"],["NB.C9"],["NB.C8"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[-1.085535,1.980763,2.04358],[-0.7596992,1.697731,2.738638],[-1.009635,1.965032,1.726025],[-1.897706,2.016882,1.528964],[-1.988084,1.837308,4.325223],[-1.555121,1.336137,1.327028],[-1.052586,2.1255,2.261516],[-1.405859,2.445933,2.212653],[-1.352712,1.968986,3.213165],[-1.979912,1.821023,0.9059321],[-1.425513,1.606863,2.766967],[-1.909455,2.270738,0.6683522]],"family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":2064},"10":{"id":10,"type":"text","material":{"lit":false},"vertices":[[-1.124418,1.988171,-1.421962],[-0.7248002,1.809312,-1.510568],[-1.02904,1.246522,-1.954188],[-1.769999,1.440239,-0.3737976],[-1.281339,1.995394,-1.397834],[-1.298018,2.201448,-0.5645762],[-0.8516427,2.033704,-1.614169],[-1.260012,2.198628,-1.208129],[-1.873685,1.929728,-1.262946],[-1.193444,2.127803,-1.023752],[-0.1105968,1.771492,-1.688935],[-0.08393253,1.189841,-2.08603],[-0.4895268,1.135108,-1.718522],[-1.334839,1.779241,-2.34599],[-1.34175,1.462347,-1.757255],[-0.7563496,1.897058,-1.076694],[-0.07262404,1.176705,-1.491112],[-1.276507,1.387789,-1.171001],[-1.273617,1.406842,-1.660411],[-1.440381,1.826292,-1.466759]],"colors":[[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1],[0,0.6196079,0.4509804,1]],"texts":[["RMS.C4"],["RMS.C3"],["RMS.C9"],["RMS.C2"],["RMS.C5"],["RMS.C6"],["RMS.C7"],["RMS.C8"],["RMS.C10"],["RMS.C11"],["RMS.T1"],["RMS.T4"],["RMS.T2"],["RMS.T6"],["RMS.T7"],["RMS.T8"],["RMS.T5"],["RMS.T3"],["RMS.T10"],["RMS.T11"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[-1.124418,1.988171,-1.421962],[-0.7248002,1.809312,-1.510568],[-1.02904,1.246522,-1.954188],[-1.769999,1.440239,-0.3737976],[-1.281339,1.995394,-1.397834],[-1.298018,2.201448,-0.5645762],[-0.8516427,2.033704,-1.614169],[-1.260012,2.198628,-1.208129],[-1.873685,1.929728,-1.262946],[-1.193444,2.127803,-1.023752],[-0.1105968,1.771492,-1.688935],[-0.08393253,1.189841,-2.08603],[-0.4895268,1.135108,-1.718522],[-1.334839,1.779241,-2.34599],[-1.34175,1.462347,-1.757255],[-0.7563496,1.897058,-1.076694],[-0.07262404,1.176705,-1.491112],[-1.276507,1.387789,-1.171001],[-1.273617,1.406842,-1.660411],[-1.440381,1.826292,-1.466759]],"family":[["sans"]],"font":[[1]],"ignoreExtent":false,"flags":2064},"12":{"id":12,"type":"lines","material":{"lit":false},"vertices":[[-2.145467,-4.674149,-2.446058],[-2.145467,2.551156,-2.446058],[-2.145467,-4.674149,4.425292],[-2.145467,2.551156,4.425292],[-2.145467,-4.674149,-2.446058],[-2.145467,-4.674149,4.425292],[-2.145467,2.551156,-2.446058],[-2.145467,2.551156,4.425292],[-2.145467,-4.674149,-2.446058],[8.661469,-4.674149,-2.446058],[-2.145467,-4.674149,4.425292],[8.661469,-4.674149,4.425292],[-2.145467,2.551156,-2.446058],[8.661469,2.551156,-2.446058],[-2.145467,2.551156,4.425292],[8.661469,2.551156,4.425292],[8.661469,-4.674149,-2.446058],[8.661469,2.551156,-2.446058],[8.661469,-4.674149,4.425292],[8.661469,2.551156,4.425292],[8.661469,-4.674149,-2.446058],[8.661469,-4.674149,4.425292],[8.661469,2.551156,-2.446058],[8.661469,2.551156,4.425292]],"colors":[[0,0,0,1]],"centers":[[-2.145467,-1.061496,-2.446058],[-2.145467,-1.061496,4.425292],[-2.145467,-4.674149,0.9896169],[-2.145467,2.551156,0.9896169],[3.258001,-4.674149,-2.446058],[3.258001,-4.674149,4.425292],[3.258001,2.551156,-2.446058],[3.258001,2.551156,4.425292],[8.661469,-1.061496,-2.446058],[8.661469,-1.061496,4.425292],[8.661469,-4.674149,0.9896169],[8.661469,2.551156,0.9896169]],"ignoreExtent":true,"flags":64},"13":{"id":13,"type":"text","material":{"lit":false},"vertices":[[3.258001,-5.216047,4.940643]],"colors":[[0,0,0,1]],"texts":[["X-variate 1: 6% expl. var"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[3.258001,-5.216047,4.940643]],"family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":2064},"14":{"id":14,"type":"text","material":{"lit":false},"vertices":[[-3.361247,-1.061497,5.198318]],"colors":[[0,0,0,1]],"texts":[["X-variate 2: 5% expl. var"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[-3.361247,-1.061497,5.198318]],"family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":2064},"15":{"id":15,"type":"text","material":{"lit":false},"vertices":[[9.471988,-5.216047,0.9896169]],"colors":[[0,0,0,1]],"texts":[["X-variate 3: 6% expl. var"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[9.471988,-5.216047,0.9896169]],"family":[["sans"]],"font":[[1]],"ignoreExtent":true,"flags":2064},"5":{"id":5,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"4":{"id":4,"type":"background","material":{"fog":true},"colors":[[0.2980392,0.2980392,0.2980392,1]],"centers":[[0,0,0]],"sphere":false,"fogtype":"none","flags":0},"6":{"id":6,"type":"background","material":{"lit":false,"back":"lines"},"colors":[[1,1,1,1]],"centers":[[0,0,0]],"sphere":false,"fogtype":"none","flags":0},"11":{"id":11,"type":"bboxdeco","material":{"front":"lines","back":"lines"},"vertices":[[0,"NA","NA"],[2,"NA","NA"],[4,"NA","NA"],[6,"NA","NA"],[8,"NA","NA"],["NA",-4,"NA"],["NA",-2,"NA"],["NA",0,"NA"],["NA",2,"NA"],["NA","NA",-2],["NA","NA",-1],["NA","NA",0],["NA","NA",1],["NA","NA",2],["NA","NA",3],["NA","NA",4]],"colors":[[0,0,0,1]],"draw_front":false,"newIds":[23,24,25,26,27,28,29]},"1":{"id":1,"type":"subscene","par3d":{"antialias":16,"FOV":30,"ignoreExtent":false,"listeners":1,"mouseMode":{"left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,31.99136],"modelMatrix":[[1,-2.454029e-06,-0.0001249672,-3.25788],[-2.454029e-06,0.9992291,-0.03925962,1.099538],[0.0001249672,0.03925962,0.999229,-32.93895],[0,0,0,1]],"projMatrix":[[3.732051,0,0,0],[0,3.732051,0,0],[0,0,-3.863703,-115.3252],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,-2.454029e-06,-0.0001249672,0],[-2.454029e-06,0.999229,-0.03925962,0],[0.0001249672,0.03925962,0.999229,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[-1.988084,8.504086,-4.568926,2.445933,-2.34599,4.325223],"windowRect":[0,45,700,745],"family":"sans","font":1,"cex":1,"useFreeType":true,"fontname":"/Library/Frameworks/R.framework/Versions/3.6/Resources/library/rgl/fonts/FreeSans.ttf","maxClipPlanes":6,"glVersion":2.1,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[6,11,7,8,9,10,12,13,14,15,5,23,24,25,26,27,28,29],"subscenes":[],"flags":2640},"23":{"id":23,"type":"lines","material":{"lit":false},"vertices":[[0,-4.674149,-2.446058],[8,-4.674149,-2.446058],[0,-4.674149,-2.446058],[0,-4.854782,-2.617842],[2,-4.674149,-2.446058],[2,-4.854782,-2.617842],[4,-4.674149,-2.446058],[4,-4.854782,-2.617842],[6,-4.674149,-2.446058],[6,-4.854782,-2.617842],[8,-4.674149,-2.446058],[8,-4.854782,-2.617842]],"colors":[[0,0,0,1]],"centers":[[4,-4.674149,-2.446058],[0,-4.764465,-2.53195],[2,-4.764465,-2.53195],[4,-4.764465,-2.53195],[6,-4.764465,-2.53195],[8,-4.764465,-2.53195]],"ignoreExtent":true,"origId":11,"flags":64},"24":{"id":24,"type":"text","material":{"lit":false},"vertices":[[0,-5.216047,-2.961409],[2,-5.216047,-2.961409],[4,-5.216047,-2.961409],[6,-5.216047,-2.961409],[8,-5.216047,-2.961409]],"colors":[[0,0,0,1]],"texts":[["0"],["2"],["4"],["6"],["8"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[0,-5.216047,-2.961409],[2,-5.216047,-2.961409],[4,-5.216047,-2.961409],[6,-5.216047,-2.961409],[8,-5.216047,-2.961409]],"family":[["sans"]],"font":[[1]],"ignoreExtent":true,"origId":11,"flags":2064},"25":{"id":25,"type":"lines","material":{"lit":false},"vertices":[[-2.145467,-4,-2.446058],[-2.145467,2,-2.446058],[-2.145467,-4,-2.446058],[-2.41564,-4,-2.617842],[-2.145467,-2,-2.446058],[-2.41564,-2,-2.617842],[-2.145467,0,-2.446058],[-2.41564,0,-2.617842],[-2.145467,2,-2.446058],[-2.41564,2,-2.617842]],"colors":[[0,0,0,1]],"centers":[[-2.145467,-1,-2.446058],[-2.280553,-4,-2.53195],[-2.280553,-2,-2.53195],[-2.280553,0,-2.53195],[-2.280553,2,-2.53195]],"ignoreExtent":true,"origId":11,"flags":64},"26":{"id":26,"type":"text","material":{"lit":false},"vertices":[[-2.955987,-4,-2.961409],[-2.955987,-2,-2.961409],[-2.955987,0,-2.961409],[-2.955987,2,-2.961409]],"colors":[[0,0,0,1]],"texts":[["-4"],["-2"],["0"],["2"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[-2.955987,-4,-2.961409],[-2.955987,-2,-2.961409],[-2.955987,0,-2.961409],[-2.955987,2,-2.961409]],"family":[["sans"]],"font":[[1]],"ignoreExtent":true,"origId":11,"flags":2064},"27":{"id":27,"type":"lines","material":{"lit":false},"vertices":[[-2.145467,-4.674149,-2],[-2.145467,-4.674149,4],[-2.145467,-4.674149,-2],[-2.41564,-4.854782,-2],[-2.145467,-4.674149,-1],[-2.41564,-4.854782,-1],[-2.145467,-4.674149,0],[-2.41564,-4.854782,0],[-2.145467,-4.674149,1],[-2.41564,-4.854782,1],[-2.145467,-4.674149,2],[-2.41564,-4.854782,2],[-2.145467,-4.674149,3],[-2.41564,-4.854782,3],[-2.145467,-4.674149,4],[-2.41564,-4.854782,4]],"colors":[[0,0,0,1]],"centers":[[-2.145467,-4.674149,1],[-2.280553,-4.764465,-2],[-2.280553,-4.764465,-1],[-2.280553,-4.764465,0],[-2.280553,-4.764465,1],[-2.280553,-4.764465,2],[-2.280553,-4.764465,3],[-2.280553,-4.764465,4]],"ignoreExtent":true,"origId":11,"flags":64},"28":{"id":28,"type":"text","material":{"lit":false},"vertices":[[-2.955987,-5.216047,-2],[-2.955987,-5.216047,-1],[-2.955987,-5.216047,0],[-2.955987,-5.216047,1],[-2.955987,-5.216047,2],[-2.955987,-5.216047,3],[-2.955987,-5.216047,4]],"colors":[[0,0,0,1]],"texts":[["-2"],["-1"],["0"],["1"],["2"],["3"],["4"]],"cex":[[1]],"adj":[[0.5,0.5]],"centers":[[-2.955987,-5.216047,-2],[-2.955987,-5.216047,-1],[-2.955987,-5.216047,0],[-2.955987,-5.216047,1],[-2.955987,-5.216047,2],[-2.955987,-5.216047,3],[-2.955987,-5.216047,4]],"family":[["sans"]],"font":[[1]],"ignoreExtent":true,"origId":11,"flags":2064},"29":{"id":29,"type":"lines","material":{"lit":false},"vertices":[[-2.145467,-4.674149,-2.446058],[-2.145467,2.551156,-2.446058],[-2.145467,-4.674149,4.425292],[-2.145467,2.551156,4.425292],[-2.145467,-4.674149,-2.446058],[-2.145467,-4.674149,4.425292],[-2.145467,2.551156,-2.446058],[-2.145467,2.551156,4.425292],[-2.145467,-4.674149,-2.446058],[8.661469,-4.674149,-2.446058],[-2.145467,-4.674149,4.425292],[8.661469,-4.674149,4.425292],[-2.145467,2.551156,-2.446058],[8.661469,2.551156,-2.446058],[-2.145467,2.551156,4.425292],[8.661469,2.551156,4.425292],[8.661469,-4.674149,-2.446058],[8.661469,2.551156,-2.446058],[8.661469,-4.674149,4.425292],[8.661469,2.551156,4.425292],[8.661469,-4.674149,-2.446058],[8.661469,-4.674149,4.425292],[8.661469,2.551156,-2.446058],[8.661469,2.551156,4.425292]],"colors":[[0,0,0,1]],"centers":[[-2.145467,-1.061496,-2.446058],[-2.145467,-1.061496,4.425292],[-2.145467,-4.674149,0.9896169],[-2.145467,2.551156,0.9896169],[3.258001,-4.674149,-2.446058],[3.258001,-4.674149,4.425292],[3.258001,2.551156,-2.446058],[3.258001,2.551156,4.425292],[8.661469,-1.061496,-2.446058],[8.661469,-1.061496,4.425292],[8.661469,-4.674149,0.9896169],[8.661469,2.551156,0.9896169]],"ignoreExtent":true,"origId":11,"flags":64}},"snapshot":"data:image/png;base64,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sfHM559//tFHH/2pn/ezY8eO+fPnv/POO0c8FWXauXPnqlWrjutDyBk+fHjs2An+s9fhnycaoAzDhg2rVatWDMvciJ0zZ05cMmHChEOHDh2PezzvvPOee+65imfzpEmTnnrqqYMHD/61u+jbt2/M2vQfWf7QQw/VrFmzdu3aVapUadWq1datW7Mf07xgwYKioqKCgoJIq++//z73s5tvvvnmF1988Z8Z5BdccEE8FSkpAxxDogHK8OOPP7Zp06Zt27YxFOOPe/bsadKkSY8ePeLy43SPUSe56Vueu+66q3fv3n92H3766ac1a9aMGDGiRo0axcXFidEwc+bMU089dfbs2REBX3zxRYsWLeLe47abNm06++yzJ06cuGzZsi5dutxzzz3ZBt97770rrrhi//79f2rf/jLRAP8K0QBlW716dUzNWG3Hyn7gwIENGzaM2VnmXF/8u/wV9htvvLFkyZLsjfpVq1bFRoYMGTJy5MgPP/wwe+tizpw5W7ZsWbdu3b333rtjx47YbIznmMfZ35Z5k0WLFl111VXt2rWLgX3gwIHsjnbv3v3888/H5H788ce3bt3622+/ld69uK9GjRrVq1evSpUqR0TDN998M3369I0bN5Y+ZnHppZfeeeeduSvPnz//4Ycfjqdi3Lhxd9xxR4RIXPj2229feOGFWSh07dr1qIdXytzbTz/9dNq0abGR7Ln94YcfYpdKSkr27dsXv9m7d+/cuXOHDh36wAMPbNiwIbefKdFwTF6XCrYPJyDRAOWKoVKnTp349eSTT541a1Z5b7yPGjWqoKBgz5492R9jztWvX3/MmDEx0iZPnlyzZs1OnTrdfvvtbdq0id+vXLky5lPM2pidESXNmjWLqRnjs2nTpjFQK7hJzOzGjRvHHXXv3j2Gfcyz9evXR8rEpvr16xfbOe2002KKV3DKwiWXXBKzMD8a1q5de8opp4wdO/aI6btr167Yt5deeikecoRC/uycMWNG586dsxM7pk6detlll8WYnzdvXq9evSp+C6S8vY1NtWzZctiwYdmOxR7Go468iESLfbjxxhvPP//8Pn36NG/ePF6F1157LXsVUqLhmLwuFWwfTkCiAcoV8zIW3LFA79+/f7a2LtOmTZuiLWKRmi1hY6zGRMzelmjfvn1uXR4zKebTiBEjYrMxnOI6+edM5KKhvJsc/uPhidh4hw4dYqZmC/24wjXXXFNUVBQjvLz9LB0NMbCXLl1a+i2K1atXZzERdxEPv1atWrFL2ekLcUcdO3aMnezZs2cM15jiscG42po1ayrolYr39q233opNLV++PH5zxhlnZE9LFg2FhYU7d+6Mm0crRJc0adIk65WUaDgmrwuQTzRAuWImxWI0pubgwYMrPhXg8ssvHzhwYDaEYrbFyjgb7bFijguzlXqsdC+++OJsbMdwyl0/k4uG8m5y+I/RsHHjxpiIK1asyI23uXPnxnTPna5YWuloKM+SJUtq164d3RCD+d133x0/fny9evUGDBiQ7XDswAsvvPDMM8/EVI7amDJlyqBBg7K/ih3etWtX6R046t7GjrVu3bpx48ajRo3KCimLhriXXBlk74tkG0k8p+Hvvy5APtEA5XrkkUdi3VlcXFyjRo3cgjVk5weE3Jvqzz77bMOGDb/99tsYmbFWzr2LHgMpJm6/fv3atWtXs2bNatWqZWcVxHAaPXp0/szLRUN5Nzn8x2iYP39+zPWYnRf9r9jCf/7zn/fff7+8VXJ6NMSKPzYe8zu3h7FvMbCzRX/+NQ8cONCqVavNmzfHpB8yZEg8USeddFL37t337NmTf82j7m1sp0mTJnGFePjZTbJoWLRoUe5p37dvX7wc06dPj+c2MRr+/usC5BMNULZY18bQihES4/Cmm25q1KjR9u3bs0FYUlLy6e+ycwviki+//DKuPG/evIkTJ8Y4zD5zETeMmVRYWPjkk08uX748Vrddu3bNOiOG0xNPPFE6GmIulneTw3+MhuzNgFdeeSVW3m/niS38/XcasjcG8gf2ypUrIxpKH4OI/RwxYkRsM8ZzUVHRZ599Fs/JlVdeGb2V/9HQo+5tXKFu3bqREbk7zaJhwYIFuX2IZyOiYdq0aenR8PdfFyCfaIAyZB+5jCmYHUHftm1bQUFB7s3tMl133XWDBw/u0qXL/fffn83LGEgxaNevX587Y6Bjx465t8HLjIbFixeXd5PDf4yGbKbGCj43U2OiP/rooxV8i0N6NMRGGjRoMG7cuNyXUsyYMSOm/pYtW/KLJJbvLVu2zFrq1ltvzR1KmDp1as+ePfOfq4r3ds+ePc2aNRszZkw8wNhgdoAju8nIkSNzj+j111+PfVi9enX64YnDf/t1AfKJBijD0KFDY66sXbs2t7CeNGlSzZo1YxyW9+VOU6ZMOeuss2KtvGHDhmwaZcfgs+MaccmECRNiC9m3HZQXDdmCvsybHP49Gq6//vrcMO7Ro0esmEtKSuKasaRu27ZtxVlTOhoiAgYMGJC/ms8pLi4+55xzsmdg69atrVu37tat2xEbHz58eG5yx6r92muv/e6772JTffv2Lf2FEBXsbQRHp06d9u/fH4nWvHnz7Lsfsmg4/fTTly1bFtuMNImbdOjQITt3Mj8apk2bdttttx1xQORYvS5APtEAR3rzzTdjRZt9Q0PuwpguMTXr16//ySeflPlJvBhadevWjeGX+xKFGLe9e/euXr16ixYt6tWrd8MNN/Tq1atOnTpPP/10JEKZ0RBzq7ybxJVHjx4d4y0G29dffx0DMkZvUVFRXLlhw4bVqlWLgVreN0lk0j9yefj3o/5XX3111apVY+JWqVKlc+fO27Zty994BMdFF120e/fu7MIY+RE0BQUF8RS1b98+dygnp7y9nTlzZpRBrPuzPlu4cGE83sWLF0deRDT0798/9vDMM8+MPSksLNy4cWP25OdHQxRebLb0PR6T1wXIJxrgOIoJt2rVqldffTX7oQ8xt+bNm1dedhz1JocOHYqZGn/MDf64Qlx51qxZ8esx//7muMeoitmzZ5d5cmVEw8cff5x/eVw/Llm3bl15e/Kn9jZ7p2HFihVRG3PmzFm6dOkx/FDDX3hdgMOiAaicctHgKxOg8hANQGUkGqASEg1AZbR3796xY8du377dIQOoPEQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASUQDAJBENAAASf4HuZBdk/Pg7bIAAAAASUVORK5CYII=","width":701,"height":701,"sphereVerts":{"vb":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.07465783,0.1464466,0.2126075,0.2705981,0.3181896,0.3535534,0.3753303,0.3826834,0.3753303,0.3535534,0.3181896,0.2705981,0.2126075,0.1464466,0.07465783,0,0,0.1379497,0.2705981,0.3928475,0.5,0.5879378,0.6532815,0.6935199,0.7071068,0.6935199,0.6532815,0.5879378,0.5,0.3928475,0.2705981,0.1379497,0,0,0.18024,0.3535534,0.51328,0.6532815,0.7681778,0.8535534,0.9061274,0.9238795,0.9061274,0.8535534,0.7681778,0.6532815,0.51328,0.3535534,0.18024,0,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,0.9807853,0.9238795,0.8314696,0.7071068,0.5555702,0.3826834,0.1950903,0,0,0.18024,0.3535534,0.51328,0.6532815,0.7681778,0.8535534,0.9061274,0.9238795,0.9061274,0.8535534,0.7681778,0.6532815,0.51328,0.3535534,0.18024,0,0,0.1379497,0.2705981,0.3928475,0.5,0.5879378,0.6532815,0.6935199,0.7071068,0.6935199,0.6532815,0.5879378,0.5,0.3928475,0.2705981,0.1379497,0,0,0.07465783,0.1464466,0.2126075,0.2705981,0.3181896,0.3535534,0.3753303,0.3826834,0.3753303,0.3535534,0.3181896,0.2705981,0.2126075,0.1464466,0.07465783,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0,-0.07465783,-0.1464466,-0.2126075,-0.2705981,-0.3181896,-0.3535534,-0.3753303,-0.3826834,-0.3753303,-0.3535534,-0.3181896,-0.2705981,-0.2126075,-0.1464466,-0.07465783,-0,-0,-0.1379497,-0.2705981,-0.3928475,-0.5,-0.5879378,-0.6532815,-0.6935199,-0.7071068,-0.6935199,-0.6532815,-0.5879378,-0.5,-0.3928475,-0.2705981,-0.1379497,-0,-0,-0.18024,-0.3535534,-0.51328,-0.6532815,-0.7681778,-0.8535534,-0.9061274,-0.9238795,-0.9061274,-0.8535534,-0.7681778,-0.6532815,-0.51328,-0.3535534,-0.18024,-0,-0,-0.1950903,-0.3826834,-0.5555702,-0.7071068,-0.8314696,-0.9238795,-0.9807853,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,-0,-0,-0.18024,-0.3535534,-0.51328,-0.6532815,-0.7681778,-0.8535534,-0.9061274,-0.9238795,-0.9061274,-0.8535534,-0.7681778,-0.6532815,-0.51328,-0.3535534,-0.18024,-0,-0,-0.1379497,-0.2705981,-0.3928475,-0.5,-0.5879378,-0.6532815,-0.6935199,-0.7071068,-0.6935199,-0.6532815,-0.5879378,-0.5,-0.3928475,-0.2705981,-0.1379497,-0,-0,-0.07465783,-0.1464466,-0.2126075,-0.2705981,-0.3181896,-0.3535534,-0.3753303,-0.3826834,-0.3753303,-0.3535534,-0.3181896,-0.2705981,-0.2126075,-0.1464466,-0.07465783,-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1],[0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,0.9807853,0.9238795,0.8314696,0.7071068,0.5555702,0.3826834,0.1950903,0,0,0.18024,0.3535534,0.51328,0.6532815,0.7681778,0.8535534,0.9061274,0.9238795,0.9061274,0.8535534,0.7681778,0.6532815,0.51328,0.3535534,0.18024,0,0,0.1379497,0.2705981,0.3928475,0.5,0.5879378,0.6532815,0.6935199,0.7071068,0.6935199,0.6532815,0.5879378,0.5,0.3928475,0.2705981,0.1379497,0,0,0.07465783,0.1464466,0.2126075,0.2705981,0.3181896,0.3535534,0.3753303,0.3826834,0.3753303,0.3535534,0.3181896,0.2705981,0.2126075,0.1464466,0.07465783,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0,-0.07465783,-0.1464466,-0.2126075,-0.2705981,-0.3181896,-0.3535534,-0.3753303,-0.3826834,-0.3753303,-0.3535534,-0.3181896,-0.2705981,-0.2126075,-0.1464466,-0.07465783,-0,-0,-0.1379497,-0.2705981,-0.3928475,-0.5,-0.5879378,-0.6532815,-0.6935199,-0.7071068,-0.6935199,-0.6532815,-0.5879378,-0.5,-0.3928475,-0.2705981,-0.1379497,-0,-0,-0.18024,-0.3535534,-0.51328,-0.6532815,-0.7681778,-0.8535534,-0.9061274,-0.9238795,-0.9061274,-0.8535534,-0.7681778,-0.6532815,-0.51328,-0.3535534,-0.18024,-0,-0,-0.1950903,-0.3826834,-0.5555702,-0.7071068,-0.8314696,-0.9238795,-0.9807853,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,-0,-0,-0.18024,-0.3535534,-0.51328,-0.6532815,-0.7681778,-0.8535534,-0.9061274,-0.9238795,-0.9061274,-0.8535534,-0.7681778,-0.6532815,-0.51328,-0.3535534,-0.18024,-0,-0,-0.1379497,-0.2705981,-0.3928475,-0.5,-0.5879378,-0.6532815,-0.6935199,-0.7071068,-0.6935199,-0.6532815,-0.5879378,-0.5,-0.3928475,-0.2705981,-0.1379497,-0,-0,-0.07465783,-0.1464466,-0.2126075,-0.2705981,-0.3181896,-0.3535534,-0.3753303,-0.3826834,-0.3753303,-0.3535534,-0.3181896,-0.2705981,-0.2126075,-0.1464466,-0.07465783,-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.07465783,0.1464466,0.2126075,0.2705981,0.3181896,0.3535534,0.3753303,0.3826834,0.3753303,0.3535534,0.3181896,0.2705981,0.2126075,0.1464466,0.07465783,0,0,0.1379497,0.2705981,0.3928475,0.5,0.5879378,0.6532815,0.6935199,0.7071068,0.6935199,0.6532815,0.5879378,0.5,0.3928475,0.2705981,0.1379497,0,0,0.18024,0.3535534,0.51328,0.6532815,0.7681778,0.8535534,0.9061274,0.9238795,0.9061274,0.8535534,0.7681778,0.6532815,0.51328,0.3535534,0.18024,0,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,0.9807853,0.9238795,0.8314696,0.7071068,0.5555702,0.3826834,0.1950903,0]],"it":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270],[17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288],[18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271]],"material":[],"normals":null,"texcoords":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1]]},"context":{"shiny":false,"rmarkdown":null},"crosstalk":{"key":[],"group":[],"id":[],"options":[]}});
_04_splsda_3drgl.prefix = "_04_splsda_3d";
</script>
<p id="_04_splsda_3ddebug">
You must enable Javascript to view this page properly.
</p>
<script>_04_splsda_3drgl.start();</script>
</div>
<div id="tuning:sPLSDA" class="section level3">
<h3><span class="header-section-number">4.7.5</span> Tuning parameters and numerical outputs</h3>
<p>For this set of methods, three parameters need to be chosen:</p>
<p>1 - The number of components to retain <code>ncomp</code>. The rule of thumb is usually <span class="math inline">\(K - 1\)</span> where <span class="math inline">\(K\)</span> is the number of classes, but it is worth testing a few extra components.</p>
<p>2 - The number of variables <code>keepX</code> to select on each component for sparse PLS-DA,</p>
<p>3 - The prediction distance to evaluate the classification and prediction performance of PLS-DA.</p>
<p>For <strong>item 1</strong>, the <code>perf</code> evaluates the performance of PLS-DA for a large number of components, using repeated k-fold cross-validation. For example here we use 3-fold CV repeated 10 times (note that we advise to use at least 50 repeats, and choose the number of folds that are appropriate for the sample size of the data set):</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb50-1" data-line-number="1">MyResult.plsda2 &lt;-<span class="st"> </span><span class="kw">plsda</span>(X,Y, <span class="dt">ncomp=</span><span class="dv">10</span>)</a>
<a class="sourceLine" id="cb50-2" data-line-number="2"><span class="kw">set.seed</span>(<span class="dv">30</span>) <span class="co"># for reproducbility in this vignette, otherwise increase nrepeat</span></a>
<a class="sourceLine" id="cb50-3" data-line-number="3">MyPerf.plsda &lt;-<span class="st"> </span><span class="kw">perf</span>(MyResult.plsda2, <span class="dt">validation =</span> <span class="st">&quot;Mfold&quot;</span>, <span class="dt">folds =</span> <span class="dv">3</span>, </a>
<a class="sourceLine" id="cb50-4" data-line-number="4">                  <span class="dt">progressBar =</span> <span class="ot">FALSE</span>, <span class="dt">nrepeat =</span> <span class="dv">10</span>) <span class="co"># we suggest nrepeat = 50</span></a>
<a class="sourceLine" id="cb50-5" data-line-number="5"></a>
<a class="sourceLine" id="cb50-6" data-line-number="6"><span class="kw">plot</span>(MyPerf.plsda, <span class="dt">col =</span> <span class="kw">color.mixo</span>(<span class="dv">5</span><span class="op">:</span><span class="dv">7</span>), <span class="dt">sd =</span> <span class="ot">TRUE</span>, <span class="dt">legend.position =</span> <span class="st">&quot;horizontal&quot;</span>)</a></code></pre></div>
<p><img src="Figures/04-plsda-perf-1-1.png" width="75%"  style="display: block; margin: auto;" /></p>
<p>The plot outputs the classification error rate, or <em>Balanced</em> classification error rate when the number of samples per group is unbalanced, the standard deviation according to three prediction distances. Here we can see that for the BER and the maximum distance, the best performance (i.e. low error rate) seems to be achieved for <code>ncomp = 3</code>.</p>
<p>In addition (<strong>item 3</strong> for PLS-DA), the numerical outputs listed here can be reported as performance measures:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb51-1" data-line-number="1">MyPerf.plsda</a></code></pre></div>
<pre><code>## 
## Call:
##  perf.mixo_plsda(object = MyResult.plsda2, validation = &quot;Mfold&quot;, folds = 3, nrepeat = 10, progressBar = FALSE) 
## 
##  Main numerical outputs: 
##  -------------------- 
##  Error rate (overall or BER) for each component and for each distance: see object$error.rate 
##  Error rate per class, for each component and for each distance: see object$error.rate.class 
##  Prediction values for each component: see object$predict 
##  Classification of each sample, for each component and for each distance: see object$class 
##  AUC values: see object$auc if auc = TRUE 
## 
##  Visualisation Functions: 
##  -------------------- 
##  plot</code></pre>
<p>Regarding <strong>item 2</strong>, we now use <code>tune.splsda</code> to assess the optimal number of variables to select on each component. We first set up a grid of <code>keepX</code> values that will be assessed on each component, one component at a time.
Similar to above we run 3-fold CV repeated 10 times with a maximum distance prediction defined as above.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb53-1" data-line-number="1">list.keepX &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">5</span><span class="op">:</span><span class="dv">10</span>,  <span class="kw">seq</span>(<span class="dv">20</span>, <span class="dv">100</span>, <span class="dv">10</span>))</a>
<a class="sourceLine" id="cb53-2" data-line-number="2">list.keepX <span class="co"># to output the grid of values tested</span></a></code></pre></div>
<pre><code>##  [1]   5   6   7   8   9  10  20  30  40  50  60  70  80  90 100</code></pre>
<div class="sourceCode" id="cb55"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="kw">set.seed</span>(<span class="dv">30</span>) <span class="co"># for reproducbility in this vignette, otherwise increase nrepeat</span></a>
<a class="sourceLine" id="cb55-2" data-line-number="2">tune.splsda.srbct &lt;-<span class="st"> </span><span class="kw">tune.splsda</span>(X, Y, <span class="dt">ncomp =</span> <span class="dv">3</span>, <span class="co"># we suggest to push ncomp a bit more, e.g. 4</span></a>
<a class="sourceLine" id="cb55-3" data-line-number="3">                                 <span class="dt">validation =</span> <span class="st">&#39;Mfold&#39;</span>,</a>
<a class="sourceLine" id="cb55-4" data-line-number="4">                                 <span class="dt">folds =</span> <span class="dv">3</span>, <span class="dt">dist =</span> <span class="st">&#39;max.dist&#39;</span>, <span class="dt">progressBar =</span> <span class="ot">FALSE</span>,</a>
<a class="sourceLine" id="cb55-5" data-line-number="5">                                 <span class="dt">measure =</span> <span class="st">&quot;BER&quot;</span>, <span class="dt">test.keepX =</span> list.keepX,</a>
<a class="sourceLine" id="cb55-6" data-line-number="6">                                 <span class="dt">nrepeat =</span> <span class="dv">10</span>)   <span class="co"># we suggest nrepeat = 50</span></a></code></pre></div>
<p>We can then extract the classification error rate averaged across all folds and repeats for each tested <code>keepX</code> value, the optimal number of components (see <code>?tune.splsda</code> for more details), the optimal number of variables to select per component which is summarised in a plot where the diamond indicated the optimal <code>keepX</code> value:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb56-1" data-line-number="1">error &lt;-<span class="st"> </span>tune.splsda.srbct<span class="op">$</span>error.rate</a>
<a class="sourceLine" id="cb56-2" data-line-number="2">ncomp &lt;-<span class="st"> </span>tune.splsda.srbct<span class="op">$</span>choice.ncomp<span class="op">$</span>ncomp <span class="co"># optimal number of components based on t-tests on the error rate</span></a>
<a class="sourceLine" id="cb56-3" data-line-number="3">ncomp</a></code></pre></div>
<pre><code>## [1] 3</code></pre>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb58-1" data-line-number="1">select.keepX &lt;-<span class="st"> </span>tune.splsda.srbct<span class="op">$</span>choice.keepX[<span class="dv">1</span><span class="op">:</span>ncomp]  <span class="co"># optimal number of variables to select</span></a>
<a class="sourceLine" id="cb58-2" data-line-number="2">select.keepX</a></code></pre></div>
<pre><code>## comp1 comp2 comp3 
##    50    40    40</code></pre>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb60-1" data-line-number="1"><span class="kw">plot</span>(tune.splsda.srbct, <span class="dt">col =</span> <span class="kw">color.jet</span>(ncomp))</a></code></pre></div>
<p><img src="Figures/04-tune-values-1.png" width="75%"  style="display: block; margin: auto;" /></p>
<p>Based on those tuning results, we can run our final and tuned sPLS-DA model:</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb61-1" data-line-number="1">MyResult.splsda.final &lt;-<span class="st"> </span><span class="kw">splsda</span>(X, Y, <span class="dt">ncomp =</span> ncomp, <span class="dt">keepX =</span> select.keepX)</a>
<a class="sourceLine" id="cb61-2" data-line-number="2"></a>
<a class="sourceLine" id="cb61-3" data-line-number="3"><span class="kw">plotIndiv</span>(MyResult.splsda.final, <span class="dt">ind.names =</span> <span class="ot">FALSE</span>, <span class="dt">legend=</span><span class="ot">TRUE</span>,</a>
<a class="sourceLine" id="cb61-4" data-line-number="4">          <span class="dt">ellipse =</span> <span class="ot">TRUE</span>, <span class="dt">title=</span><span class="st">&quot;sPLS-DA - final result&quot;</span>)</a></code></pre></div>
<p><img src="Figures/04-final-splsda-1.png" width="75%"  style="display: block; margin: auto;" /></p>
<p>Additionally, we can run <code>perf</code> for the final performance of the sPLS-DA model. Also, note that <code>perf</code> will output <code>features</code> that lists the frequency of selection of the variables across the different folds and different repeats. This is a useful output to assess the confidence of your final variable selection, see a more <a href="http://mixomics.org/case-studies/splsda-srbct/">detailed example here</a>.</p>
</div>
</div>
<div id="additional-resources-1" class="section level2">
<h2><span class="header-section-number">4.8</span> Additional resources</h2>
<p>Additional examples are provided in <code>example(splsda)</code> and in our case studies on our <a href="http://www.mixomics.org">website</a> in the <strong>Methods</strong> and <strong>Case studies</strong> sections, and in particular <a href="http://mixomics.org/case-studies/splsda-srbct/">here</a>. Also have a look at <span class="citation">(Lê Cao, Boitard, and Besse <a href="#ref-Lec11">2011</a>)</span></p>
</div>
<div id="faq-1" class="section level2">
<h2><span class="header-section-number">4.9</span> FAQ</h2>
<ul>
<li>Can I discriminate more than two groups of samples (multiclass classification)?
<ul>
<li>Yes, this is one of the advantages of PLS-DA, see this example above</li>
</ul></li>
<li>Can I have a hierarchy between two factors (e.g. diet nested into genotype)?
<ul>
<li>Unfortunately no, sparse PLS-DA only allows to discriminate all groups at once (i.e. 4 x 2 groups when there are 4 diets and 2 genotypes)</li>
</ul></li>
<li>Can I have missing values in my data?
<ul>
<li>Yes in the X data set, but you won’t be able to do any prediction (i.e. <code>tune, perf, predict</code>)</li>
<li>No in the Y factor</li>
</ul></li>
</ul>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-Bar03">
<p>Barker, Matthew, and William Rayens. 2003. “Partial Least Squares for Discrimination.” <em>Journal of Chemometrics</em> 17 (3). Wiley Online Library: 166–73.</p>
</div>
<div id="ref-Bou07">
<p>Boulesteix, A.L., and K. Strimmer. 2007. “Partial least squares: a versatile tool for the analysis of high-dimensional genomic data.” <em>Briefings in Bioinformatics</em> 8 (1). Oxford Univ Press: 32.</p>
</div>
<div id="ref-Chung10">
<p>Chung, D., and S. Keles. 2010. “Sparse Partial Least Squares Classification for High Dimensional Data.” <em>Statistical Applications in Genetics and Molecular Biology</em> 9 (1). bepress: 17.</p>
</div>
<div id="ref-Kha01">
<p>Khan, Javed, Jun S Wei, Markus Ringner, Lao H Saal, Marc Ladanyi, Frank Westermann, Frank Berthold, et al. 2001. “Classification and Diagnostic Prediction of Cancers Using Gene Expression Profiling and Artificial Neural Networks.” <em>Nature Medicine</em> 7 (6). Nature Publishing Group: 673–79.</p>
</div>
<div id="ref-Lec11">
<p>Lê Cao, Kim-Anh, Simon Boitard, and Philippe Besse. 2011. “Sparse PLS Discriminant Analysis: Biologically Relevant Feature Selection and Graphical Displays for Multiclass Problems.” <em>BMC Bioinformatics</em> 12 (1). BioMed Central Ltd: 253.</p>
</div>
<div id="ref-Ngu02a">
<p>Nguyen, D.V., and D.M. Rocke. 2002. “Tumor classification by partial least squares using microarray gene expression data.” <em>Bioinformatics</em> 18 (1). Oxford Univ Press: 39.</p>
</div>
<div id="ref-mixomics">
<p>Rohart, F, B Gautier, A Singh, and K-A Lê Cao. 2017. “MixOmics: An R Package for ‘Omics Feature Selection and Multiple Data Integration.” <em>PLoS Computational Biology</em> 13 (11). Cold Spring Harbor Labs Journals.</p>
</div>
<div id="ref-Tan04">
<p>Tan, Y., L. Shi, W. Tong, GT Gene Hwang, and C. Wang. 2004. “Multi-class tumor classification by discriminant partial least squares using microarray gene expression data and assessment of classification models.” <em>Computational Biology and Chemistry</em> 28 (3). Elsevier: 235–43.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="pca.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="pls.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/rstudio/bookdown-demo/edit/master/04-PLSDA.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"download": ["Vignette-mixOmics.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
